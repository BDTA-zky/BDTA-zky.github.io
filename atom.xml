<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大数据科技协会-zky</title>
  
  
  <link href="https://bdta-zky.github.io/atom.xml" rel="self"/>
  
  <link href="https://bdta-zky.github.io/"/>
  <updated>2024-01-01T07:06:10.060Z</updated>
  <id>https://bdta-zky.github.io/</id>
  
  <author>
    <name>刘浩龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>糖尿病预测分析：探索Pima印第安人数据集中的奥秘</title>
    <link href="https://bdta-zky.github.io/%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%EF%BC%9A%E6%8E%A2%E7%B4%A2Pima%E5%8D%B0%E7%AC%AC%E5%AE%89%E4%BA%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E7%9A%84%E5%A5%A5%E7%A7%98/"/>
    <id>https://bdta-zky.github.io/%E7%B3%96%E5%B0%BF%E7%97%85%E9%A2%84%E6%B5%8B%E5%88%86%E6%9E%90%EF%BC%9A%E6%8E%A2%E7%B4%A2Pima%E5%8D%B0%E7%AC%AC%E5%AE%89%E4%BA%BA%E6%95%B0%E6%8D%AE%E9%9B%86%E4%B8%AD%E7%9A%84%E5%A5%A5%E7%A7%98/</id>
    <published>2024-01-01T06:53:01.000Z</published>
    <updated>2024-01-01T07:06:10.060Z</updated>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>​       糖尿病是一种全球性的慢性代谢性疾病，对患者的生活质量和健康产生深远的影响。为了更好地理解和预测糖尿病的发病机制，我们选择了著名的Pima印第安人糖尿病数据集，通过数据分析和机器学习技术，试图揭示其中隐藏的规律和特征。</p><h1 id="数据探索"><a href="#数据探索" class="headerlink" title="数据探索"></a>数据探索</h1><h2 id="数据集概览"><a href="#数据集概览" class="headerlink" title="数据集概览"></a>数据集概览</h2><p>​      我们从UCI机器学习库中获取了Pima印第安人糖尿病数据集，该数据集一共有768行，9列，包含了8个生理特征和一个目标变量（是否患有糖尿病）。通过对数据的初步探索，我们获得了关于患糖尿病和非患糖尿病样本的分布比例以及各特征的基本统计信息。</p><h2 id="数据可视化"><a href="#数据可视化" class="headerlink" title="数据可视化"></a>数据可视化</h2><p>​       通过绘制直方图和相关矩阵热力图，我们深入了解了患糖尿病和非患糖尿病样本中特征之间的关系。特别是，我们关注了 ‘plasma_glucose_concentration’、’bmi’ 等关键特征的分布差异，为后续的分析奠定了基础。</p><h1 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h1><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>​       在数据预处理阶段，我们采用了两种不同的缺失值处理方式：删除包含缺失值的行和填充缺失值。这一步骤旨在准备数据，使其更适合机器学习模型的训练。以下是进行缺失值处理的代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># （11）替换零值</span></span><br><span class="line">columns = [<span class="string">&#x27;serum_insulin&#x27;</span>, <span class="string">&#x27;bmi&#x27;</span>, <span class="string">&#x27;plasma_glucose_concentration&#x27;</span>, <span class="string">&#x27;diastolic_blood_pressure&#x27;</span>, <span class="string">&#x27;triceps_thickness&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> columns:</span><br><span class="line">    pima[col].replace([<span class="number">0</span>], [<span class="literal">None</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （14）删除含有缺失值的行</span></span><br><span class="line">pima_dropped = pima.dropna()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （23）使用中位数填充缺失值</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line">imputer = SimpleImputer(strategy=<span class="string">&quot;median&quot;</span>)</span><br><span class="line">pima_imputed = pd.DataFrame(imputer.fit_transform(pima), columns=pima_column_names)</span><br></pre></td></tr></table></figure><h2 id="机器学习建模"><a href="#机器学习建模" class="headerlink" title="机器学习建模"></a><strong>机器学习建模</strong></h2><h3 id="K最近邻（KNN）分类器"><a href="#K最近邻（KNN）分类器" class="headerlink" title="K最近邻（KNN）分类器"></a>K最近邻（KNN）分类器</h3><p>​    我们选择了KNN分类器作为预测模型，通过使用网格搜索优化参数，找到了最优的模型参数组合。通过对填充缺失值和删除缺失值两种数据集进行训练和评估，我们比较了模型在不同数据集上的性能表现。以下是此模块代码：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 使用KNN模型进行网格搜索优化</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义了KNN模型的参数范围</span></span><br><span class="line">knn_params = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化了一个KNN分类器</span></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用网格搜索优化</span></span><br><span class="line">grid = GridSearchCV(knn, knn_params)</span><br><span class="line">grid.fit(X_train, y_train)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 输出了网格搜索得到的最佳模型的准确率和对应的最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳准确率:&quot;</span>, grid.best_score_)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;最佳参数:&quot;</span>, grid.best_params_)</span><br></pre></td></tr></table></figure><h1 id="结果与讨论"><a href="#结果与讨论" class="headerlink" title="结果与讨论"></a>结果与讨论</h1><p>​          我们选择了KNN分类器作为预测模型，通过使用网格搜索优化参数，找到了最优的模型参数组合。通过对填充缺失值和删除缺失值两种数据集进行训练和评估，我们比较了模型在不同数据集上的性能表现。</p><p>总结与展望<br>         通过本次研究，我们深入探讨了Pima印第安人糖尿病数据集，通过数据可视化和机器学习模型揭示了潜在的糖尿病预测因素。我们的研究为糖尿病的早期干预和预防提供了一定的理论支持，并为未来的研究提出了一些可行的方向。</p><p>​        在未来，我们可以考虑引入更多特征和更复杂的模型，以提高预测的准确性。同时，将模型应用于更大规模的数据集，验证其在真实场景中的稳定性和泛化能力，为糖尿病研究和预防工作提供更有力的支持。</p><p>​       通过这次研究，我们希望为广大研究者和从业者提供一个深入了解糖尿病预测分析的案例，为未来相关研究和实践工作提供启示。</p><h1 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h1><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#（1）导入库：导入了进行数据处理的必要库，并设置了内联绘图的环境。</span></span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line">%matplotlib inline</span><br><span class="line">plt.style.use(<span class="string">&#x27;fivethirtyeight&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#加载数据集，添加标题</span></span><br><span class="line">pima_column_names = [<span class="string">&#x27;times_pregnant&#x27;</span>, <span class="string">&#x27;plasma_glucose_concentration&#x27;</span>, <span class="string">&#x27;diastolic_blood_pressure&#x27;</span>, <span class="string">&#x27;triceps_thickness&#x27;</span>,</span><br><span class="line">                    <span class="string">&#x27;serum_insulin&#x27;</span>, <span class="string">&#x27;bmi&#x27;</span>, <span class="string">&#x27;pedigree_function&#x27;</span>, <span class="string">&#x27;age&#x27;</span>, <span class="string">&#x27;onset_diabetes&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 源数据的csv文件没有列名，需手动添加</span></span><br><span class="line">path =<span class="string">&#x27;D:\pima-indians-diabetes.csv&#x27;</span></span><br><span class="line"><span class="comment"># header=0 少一行</span></span><br><span class="line">pima = pd.read_csv(path,header=<span class="number">0</span>,names=pima_column_names)</span><br><span class="line">pima.head()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （2）用于显示数据集 pima的行数和列数</span></span><br><span class="line">pima.shape</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （3）计算一下空准确率：输出目标变量 &#x27;onset_diabetes&#x27; 中每个类别的相对频率（归一化计数），以及类别标签（onset_diabetes）</span></span><br><span class="line">pima[<span class="string">&#x27;onset_diabetes&#x27;</span>].value_counts(normalize=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （4）对plasma_glucose_concentration（血浆葡萄糖浓度）列绘制直方图（0，1出现的频率）</span></span><br><span class="line">col = <span class="string">&#x27;plasma_glucose_concentration&#x27;</span></span><br><span class="line"><span class="comment"># 不患糖尿病（bins=10 指定了直方图的箱数，alpha=0.5 设置了透明度）</span></span><br><span class="line">plt.hist(pima[pima[<span class="string">&#x27;onset_diabetes&#x27;</span>]==<span class="number">0</span>][col],bins=<span class="number">10</span>,alpha=<span class="number">0.5</span>,label=<span class="string">&#x27;non-diabetes&#x27;</span>)</span><br><span class="line"><span class="comment"># 患糖尿病</span></span><br><span class="line">plt.hist(pima[pima[<span class="string">&#x27;onset_diabetes&#x27;</span>]==<span class="number">1</span>][col],bins=<span class="number">10</span>,alpha=<span class="number">0.5</span>,label=<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line">plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">plt.xlabel(col)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;Histogram of &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(col))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （5）绘制其他列的直方图（bmi：身体质量数 diastolic_blood_pressure：心脏舒张压 plasma_glucose_concentration：血浆葡萄糖浓度）</span></span><br><span class="line">cols = [<span class="string">&#x27;bmi&#x27;</span>,<span class="string">&#x27;diastolic_blood_pressure&#x27;</span>,<span class="string">&#x27;plasma_glucose_concentration&#x27;</span>]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> cols:</span><br><span class="line">    <span class="comment"># 不患糖尿病</span></span><br><span class="line">    plt.hist(pima[pima[<span class="string">&#x27;onset_diabetes&#x27;</span>]==<span class="number">0</span>][col],bins=<span class="number">10</span>,alpha=<span class="number">0.5</span>,label=<span class="string">&#x27;non-diabetes&#x27;</span>)</span><br><span class="line">    <span class="comment"># 患糖尿病</span></span><br><span class="line">    plt.hist(pima[pima[<span class="string">&#x27;onset_diabetes&#x27;</span>]==<span class="number">1</span>][col],bins=<span class="number">10</span>,alpha=<span class="number">0.5</span>,label=<span class="string">&#x27;diabetes&#x27;</span>)</span><br><span class="line">    plt.legend(loc=<span class="string">&#x27;upper right&#x27;</span>)</span><br><span class="line">    plt.xlabel(col)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Frequency&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Histogram of &#123;&#125;&#x27;</span>.<span class="built_in">format</span>(col))</span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （6）pima.corr() 计算了数据集中所有数值型特征之间的相关性sns.heatmap() 函数绘制了相关矩阵的热力图，热力图中不同颜色对应不同的相关性亮色表示正相关，暗色表示负相关。</span></span><br><span class="line">sns.heatmap(pima.corr())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （7）计算了数据集之间的相关性每个特征与目标变量的皮尔逊相关系数，值越接近1表示正相关，越接近-1表示负相关。</span></span><br><span class="line">pima.corr()[<span class="string">&#x27;onset_diabetes&#x27;</span>].sort_values(ascending=<span class="literal">False</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （8）计算数据集 pima 中每个特征的缺失值数量</span></span><br><span class="line">pima.isnull().<span class="built_in">sum</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （9）查看数据的基本描述性统计（均值、标准差、最小值、25% 分位数、中位数（50% 分位数）、75% 分位数和最大值）</span></span><br><span class="line">pima.describe()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （10）手动将每列的0替换成None，将实际的0值标记为缺失值</span></span><br><span class="line"><span class="built_in">print</span>(pima[<span class="string">&#x27;serum_insulin&#x27;</span>].isnull().<span class="built_in">sum</span>())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用None手动替换0</span></span><br><span class="line">pima[<span class="string">&#x27;serum_insulin&#x27;</span>]=pima[<span class="string">&#x27;serum_insulin&#x27;</span>].<span class="built_in">map</span>(<span class="keyword">lambda</span> x:x <span class="keyword">if</span> x!=<span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 检查替换后的缺失值数量</span></span><br><span class="line"><span class="built_in">print</span>(pima[<span class="string">&#x27;serum_insulin&#x27;</span>].isnull().<span class="built_in">sum</span>())</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （11）直接对所有列操作</span></span><br><span class="line">columns = [<span class="string">&#x27;serum_insulin&#x27;</span>, <span class="string">&#x27;bmi&#x27;</span>, <span class="string">&#x27;plasma_glucose_concentration&#x27;</span>, <span class="string">&#x27;diastolic_blood_pressure&#x27;</span>, <span class="string">&#x27;triceps_thickness&#x27;</span>]</span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> columns:</span><br><span class="line">    pima[col].replace([<span class="number">0</span>], [<span class="literal">None</span>], inplace=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 查看缺失值情况</span></span><br><span class="line">pima.isnull().<span class="built_in">sum</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （12）查看数据集 pima 的前几行，以查看对列中的0值替换为None的效果</span></span><br><span class="line">pima.head()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （13）不包含有缺失值的列，提供没有缺失值的列的统计摘要</span></span><br><span class="line">pima.describe() </span><br><span class="line"> </span><br><span class="line"><span class="comment"># （14）删除存在缺失的行，简化数据集，指示删除了多少百分比的行</span></span><br><span class="line">pima_dropped = pima.dropna()</span><br><span class="line"><span class="comment"># 检查删除了多少行</span></span><br><span class="line">num_rows_lost = <span class="built_in">round</span>(<span class="number">100</span>*(pima.shape[<span class="number">0</span>] - pima_dropped.shape[<span class="number">0</span>]) / <span class="built_in">float</span>(pima.shape[<span class="number">0</span>]))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;删除 &#123;&#125;%&quot;</span>.<span class="built_in">format</span>(num_rows_lost))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （15）未删除数据的空准确率，在未删除包含缺失值的数据集中0，1占比</span></span><br><span class="line">pima[<span class="string">&#x27;onset_diabetes&#x27;</span>].value_counts(normalize=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （16）删除数据后的空准确率</span></span><br><span class="line">pima_dropped[<span class="string">&#x27;onset_diabetes&#x27;</span>].value_counts(normalize=<span class="literal">True</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （17）未删除数据的均值</span></span><br><span class="line">pima.mean()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （18）删除数据后的均值</span></span><br><span class="line">pima_dropped.mean()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （19）计算未删除缺失值的数据集 pima_dropped 与原始数据集 pima 中数值型列的均值变化百分比</span></span><br><span class="line">ax = ((pima_dropped.mean() - pima.mean()) / pima.mean()).plot(kind=<span class="string">&#x27;bar&#x27;</span>, title=<span class="string">&#x27;% change in average column values&#x27;</span>)</span><br><span class="line">ax.set_ylabel(<span class="string">&#x27;% change&#x27;</span>)<span class="comment">#正值表示均值上升，负值表示均值下降</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># （20）使用K最近邻（KNN）分类器对未删除缺失值的数据集进行建模，并通过网格搜索找到最佳的K值</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 删除标签数据</span></span><br><span class="line">X_dropped = pima_dropped.drop(<span class="string">&#x27;onset_diabetes&#x27;</span>, axis=<span class="number">1</span>)  <span class="comment"># 特征</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;leanrning from &#123;&#125; rows&quot;</span>.<span class="built_in">format</span>(X_dropped.shape[<span class="number">0</span>]))</span><br><span class="line">y_dropped = pima_dropped[<span class="string">&#x27;onset_diabetes&#x27;</span>]   <span class="comment"># 标签</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># 定义了KNN模型的参数范围</span></span><br><span class="line">knn_params = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化了一个KNN分类器，该分类器在后续步骤中将被用于网格搜索</span></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用网格搜索优化</span></span><br><span class="line">grid = GridSearchCV(knn, knn_params)</span><br><span class="line">grid.fit(X_dropped, y_dropped)</span><br><span class="line"> </span><br><span class="line"><span class="comment">#  输出了网格搜索得到的最佳模型的准确率和对应的最佳参数</span></span><br><span class="line"><span class="built_in">print</span>(grid.best_score_, grid.best_params_)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （21）查看缺失值情况</span></span><br><span class="line">pima.isnull().<span class="built_in">sum</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （22）用fillna方法填充， 再次查看整个数据集中的缺失值数量。</span></span><br><span class="line">pima[<span class="string">&#x27;plasma_glucose_concentration&#x27;</span>].fillna(pima[<span class="string">&#x27;plasma_glucose_concentration&#x27;</span>].mean(),inplace=<span class="literal">True</span>)</span><br><span class="line">pima.isnull().<span class="built_in">sum</span>()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （23）使用scikit-learn预处理类的Imputer模块</span></span><br><span class="line"><span class="keyword">from</span> sklearn.impute <span class="keyword">import</span> SimpleImputer</span><br><span class="line"><span class="comment"># 实例化Imputer对象并指定了使用中位数填充缺失值的策略。</span></span><br><span class="line">imputer = SimpleImputer(strategy=<span class="string">&quot;median&quot;</span>)</span><br><span class="line"><span class="comment"># 创建新对象并填充缺失值</span></span><br><span class="line">pima_imputed = imputer.fit_transform(pima)</span><br><span class="line"><span class="comment"># 将得到的ndarray类型转化为DataFrame并设置列名为原始数据集的列名。</span></span><br><span class="line">pima_imputed = pd.DataFrame(pima_imputed, columns=pima_column_names)</span><br><span class="line"><span class="comment">#输出填充后的数据的前几行</span></span><br><span class="line">pima_imputed.head()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># （24）在填充缺失值后判断是否有缺失值</span></span><br><span class="line">pima_imputed.isnull().<span class="built_in">sum</span>()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">#（25）</span></span><br><span class="line"><span class="keyword">from</span> sklearn.neighbors <span class="keyword">import</span> KNeighborsClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> GridSearchCV</span><br><span class="line"><span class="keyword">import</span> warnings</span><br><span class="line">warnings.filterwarnings(<span class="string">&#x27;ignore&#x27;</span>)</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 用0填充，创建特征集和标签集</span></span><br><span class="line">pima_zero = pima.fillna(<span class="number">0</span>)</span><br><span class="line">X_zero = pima_zero.drop(<span class="string">&#x27;onset_diabetes&#x27;</span>, axis=<span class="number">1</span>)</span><br><span class="line">y_zero = pima_zero[<span class="string">&#x27;onset_diabetes&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;learning from &#123;&#125; rows&quot;</span>.<span class="built_in">format</span>(X_zero.shape[<span class="number">0</span>]))</span><br><span class="line"> </span><br><span class="line"><span class="comment"># KNN的模型参数用不同的邻居数进行网格搜索</span></span><br><span class="line">knn_params = &#123;<span class="string">&#x27;n_neighbors&#x27;</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]&#125;</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 实例化了一个KNN分类器，该分类器在后续步骤中将被用于网格搜索</span></span><br><span class="line">knn = KNeighborsClassifier()</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 使用网格搜索优化，通过在给定的参数范围内搜索最佳参数组合，以获得最佳的KNN模型。</span></span><br><span class="line">grid = GridSearchCV(knn, knn_params)</span><br><span class="line">grid.fit(X_zero, y_zero)</span><br><span class="line"><span class="comment"># 输出了网格搜索得到的最佳模型的准确率和对应的最佳参数。</span></span><br><span class="line"><span class="built_in">print</span>(grid.best_score_, grid.best_params_)</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;引言&quot;&gt;&lt;a href=&quot;#引言&quot; class=&quot;headerlink&quot; title=&quot;引言&quot;&gt;&lt;/a&gt;引言&lt;/h1&gt;&lt;p&gt;​       糖尿病是一种全球性的慢性代谢性疾病，对患者的生活质量和健康产生深远的影响。为了更好地理解和预测糖尿病的发病机制，我们选择了著</summary>
      
    
    
    
    
    <category term="数据挖掘" scheme="https://bdta-zky.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    <category term="KNN" scheme="https://bdta-zky.github.io/tags/KNN/"/>
    
  </entry>
  
  <entry>
    <title>解密垃圾邮件分类：基于SVM的数据挖掘项目</title>
    <link href="https://bdta-zky.github.io/%E8%A7%A3%E5%AF%86%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB%EF%BC%9A%E5%9F%BA%E4%BA%8ESVM%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E9%A1%B9%E7%9B%AE/"/>
    <id>https://bdta-zky.github.io/%E8%A7%A3%E5%AF%86%E5%9E%83%E5%9C%BE%E9%82%AE%E4%BB%B6%E5%88%86%E7%B1%BB%EF%BC%9A%E5%9F%BA%E4%BA%8ESVM%E7%9A%84%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98%E9%A1%B9%E7%9B%AE/</id>
    <published>2024-01-01T06:52:20.000Z</published>
    <updated>2024-01-01T07:00:26.402Z</updated>
    
    <content type="html"><![CDATA[<p>😀 垃圾邮件（Spam）的泛滥成灾一直是电子邮件系统中的一个严峻问题。随着垃圾邮件技术的不断演变，传统的过滤方法逐渐显得力不从心。因此，本项目旨在利用支持向量机（SVM）这一强大的机器学习工具，实现对垃圾邮件的高效分类，为用户提供更清爽、高效的电子邮件体验。</p><h1 id="一、项目目标"><a href="#一、项目目标" class="headerlink" title="一、项目目标"></a>一、项目目标</h1><blockquote><p>本项目的主要目标是构建一个基于SVM的垃圾邮件分类系统。通过对两个不同来源的数据集（trec 和 enron）进行综合分析和处理，我将展示整个数据挖掘项目的过程，包括数据的<strong>预处理、特征工程、模型训练与调优</strong>，并最终通过<strong>实验结果</strong>分析验证模型的性能。</p></blockquote><h1 id="二、数据集来源及介绍"><a href="#二、数据集来源及介绍" class="headerlink" title="二、数据集来源及介绍"></a>二、数据集来源及介绍</h1><p><strong>我使用了两个不同来源的数据集，其中trec数据集已经经过处理，enron数据集需要进行清洗和整理：</strong></p><ul><li><strong>trec</strong>（<a href="https://www.kaggle.com/datasets/bayes2003/emails-for-spam-or-ham-classification-trec-2007">Emails for spam or ham classification (Trec 2007) (kaggle.com)</a></li><li><strong>enron</strong>（<a href="https://github.com/MWiechmann/enron_spam_data/">MWiechmann/enron_spam_data: The Enron-Spam dataset preprocessed in a single, clean csv file. (github.com)</a></li></ul><p>trec 数据集提供了多样的垃圾邮件和非垃圾邮件样本，而 enron 数据集则包含了来自 enron 公司的电子邮件数据。这两个数据集的结合将有助于提高模型的泛化能力。</p><h1 id="三、数据处理与准备"><a href="#三、数据处理与准备" class="headerlink" title="三、数据处理与准备"></a>三、<strong>数据处理与准备</strong></h1><blockquote><p><strong>在进行垃圾邮件分类项目之前，我们首先需要对数据进行准备和预处理。</strong></p></blockquote><h2 id="3-1-trec数据集"><a href="#3-1-trec数据集" class="headerlink" title="3.1 trec数据集"></a>3.1 <strong>trec数据集</strong></h2><h3 id="3-1-1-数据导入与查看"><a href="#3-1-1-数据导入与查看" class="headerlink" title="3.1.1 数据导入与查看"></a><strong>3.1.1 数据导入与查看</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">trec = pd.read_csv(<span class="string">r&quot;D:\\BUZZ\\\\数据挖掘\\垃圾邮件分类\\email_text.csv&quot;</span>)</span><br><span class="line">display(trec)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>数据一开始就是预处理过的，因此通过导入数据和查看前几行，我们可以验证数据的完整性，确保没有导入错误或缺失的信息。</p><h3 id="3-1-2-缺失值和重复值处理"><a href="#3-1-2-缺失值和重复值处理" class="headerlink" title="3.1.2 缺失值和重复值处理"></a><strong>3.1.2 缺失值和重复值处理</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">trec.isna().<span class="built_in">sum</span>()</span><br><span class="line">trec.duplicated().<span class="built_in">sum</span>()</span><br></pre></td></tr></table></figure><p><strong>原因：</strong>尽管数据已经被预处理，但为了确保数据的完整性，我们仍然进行了缺失值和重复值的验证。使用**<code>isna()</code><strong>方法检查每一列是否存在缺失值，</strong><code>sum()</code><strong>方法得到缺失值的数量。使用</strong><code>duplicated()</code><strong>方法检查是否有重复行，</strong><code>sum()</code>**方法计算重复值的数量。</p><h2 id="3-2-enron数据集"><a href="#3-2-enron数据集" class="headerlink" title="3.2 enron数据集"></a>3.2 <strong>enron数据集</strong></h2><h3 id="3-2-1-数据导入与查看"><a href="#3-2-1-数据导入与查看" class="headerlink" title="3.2.1 数据导入与查看"></a><strong>3.2.1 数据导入与查看</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">enron = pd.read_csv(<span class="string">r&quot;D:\\BUZZ\\\\数据挖掘\\垃圾邮件分类\\enron_spam_data.csv&quot;</span>)</span><br><span class="line">display(enron)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> enron数据集的导入和查看步骤与trec相似。同样，通过导入数据和查看前几行，我们验证了数据的完整性。</p><h3 id="3-2-2-缺失值和重复值处理"><a href="#3-2-2-缺失值和重复值处理" class="headerlink" title="3.2.2 缺失值和重复值处理"></a><strong>3.2.2 缺失值和重复值处理</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">enron.isna().<span class="built_in">sum</span>()</span><br><span class="line">enron.duplicated().<span class="built_in">sum</span>()</span><br><span class="line">enron.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line">enron.drop_duplicates(inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 与trec不同，enron数据集是原始数据，未经过预处理。我们首先使用**<code>isna()</code><strong>方法检查缺失值，</strong><code>sum()</code><strong>方法得到每列缺失值的数量。然后，使用</strong><code>duplicated()</code><strong>方法检查重复值，</strong><code>sum()</code><strong>方法计算重复值的数量。接着，使用</strong><code>dropna</code><strong>方法删除缺失值，</strong><code>drop_duplicates</code>**方法删除重复值。</p><h3 id="3-2-3-数据选择性分析与处理"><a href="#3-2-3-数据选择性分析与处理" class="headerlink" title="3.2.3 数据选择性分析与处理"></a><strong>3.2.3 数据选择性分析与处理</strong></h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">pythonCopy code</span><br><span class="line"><span class="comment"># 只分析邮件正文内容，因此不需要其他列</span></span><br><span class="line">enron.drop([<span class="string">&#x27;Message ID&#x27;</span>, <span class="string">&quot;Subject&quot;</span>, <span class="string">&quot;Date&quot;</span>], axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查缺失值</span></span><br><span class="line">enron.isna().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除缺失值</span></span><br><span class="line">enron.dropna(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查重复值</span></span><br><span class="line">enron.duplicated().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除重复值</span></span><br><span class="line">enron.drop_duplicates(inplace=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 LabelEncoder 将 &quot;ham&quot; 替换为 0，&quot;spam&quot; 替换为 1</span></span><br><span class="line">label_encoder = preprocessing.LabelEncoder()</span><br><span class="line">enron[<span class="string">&#x27;label&#x27;</span>] = label_encoder.fit_transform(enron[<span class="string">&#x27;Spam/Ham&#x27;</span>])</span><br><span class="line">enron.drop(<span class="string">&#x27;Spam/Ham&#x27;</span>, axis=<span class="number">1</span>, inplace=<span class="literal">True</span>)</span><br><span class="line">enron.rename(columns=&#123;<span class="string">&#x27;Message&#x27;</span>: <span class="string">&#x27;text&#x27;</span>&#125;, inplace=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 由于我们只对邮件正文内容进行分析，因此在这一步骤中，我们删除了与正文内容无关的列。然后，我们再次检查并处理缺失值和重复值。最后，使用**<code>LabelEncoder</code>**将”ham”标记为0，”spam”标记为1，为模型训练做准备。</p><h2 id="3-3-数据合并、抽样及划分"><a href="#3-3-数据合并、抽样及划分" class="headerlink" title="3.3 数据合并、抽样及划分"></a><strong>3.3 数据合并、抽样及划分</strong></h2><blockquote><p>在这一步中，我首先合并了trec和enron两个数据集，再次检查了合并后的数据集是否有重复值。然后，我进行了随机抽样，保留了原始数据集的10%。最后，我使用**<code>train_test_split</code>**方法将数据集划分为训练集和测试集，其中20%分给测试集，80%分给训练集。这样的划分有助于我们在训练模型时验证其性能。</p></blockquote><h3 id="3-3-1-数据合并与抽样"><a href="#3-3-1-数据合并与抽样" class="headerlink" title="3.3.1 数据合并与抽样"></a>3.3.1 数据合并与抽样</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">combined = pd.concat([trec, enron], ignore_index=<span class="literal">True</span>)</span><br><span class="line">combined.duplicated().<span class="built_in">sum</span>()</span><br><span class="line">combined = combined.sample(frac=<span class="number">0.1</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 将两个数据集合并为一个可以帮助我们更方便地进行后续的分析和建模。为了减小数据规模，提高模型训练效率，我们使用了**<code>sample</code>**方法对合并后的数据进行了随机抽样。这也有助于避免在处理大规模数据时过度占用计算资源。</p><h3 id="3-3-2-数据集划分"><a href="#3-3-2-数据集划分" class="headerlink" title="3.3.2 数据集划分"></a>3.3.2 数据集划分</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">pythonCopy code</span><br><span class="line"><span class="comment"># 合并数据集</span></span><br><span class="line">combined = pd.concat([trec, enron], ignore_index=<span class="literal">True</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合并后检查重复值</span></span><br><span class="line">combined.duplicated().<span class="built_in">sum</span>()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对 combined 数据集进行随机抽样，保留原始数据集的 10%</span></span><br><span class="line">combined = combined.sample(frac=<span class="number">0.1</span>, random_state=<span class="number">1</span>)</span><br><span class="line">combined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 分割数据集 （20%分给测试集，80%分给训练集）</span></span><br><span class="line">x = combined[<span class="string">&#x27;text&#x27;</span>]</span><br><span class="line">y = combined[<span class="string">&#x27;label&#x27;</span>]</span><br><span class="line">x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=<span class="number">0.2</span>, random_state=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>将数据集划分为训练集和测试集，其中20%分给测试集，80%分给训练集。这样的划分有助于我们在训练模型时验证其性能。</p><hr><p><strong>注释解释：</strong></p><ul><li><strong>删除缺失值的原因：</strong> 电子邮件正文缺失对垃圾邮件分类任务没有直接贡献，且数目较少，因此选择直接删除缺失值。这有助于保持数据集的质量和可用性。</li><li>删除重复值的原因：<ol><li><strong>过拟合风险：</strong> 数据集中存在重复的电子邮件可能导致模型在新数据上的泛化性能下降，因为模型会过度学习这些重复的模式。</li><li><strong>样本偏好：</strong> 如果某些电子邮件出现多次，模型可能更倾向于这些样本，引入对特定电子邮件的偏好。删除重复值有助于保持数据集的平衡性。</li><li><strong>简化数据集：</strong> 删除重复值可以简化数据集，使数据更干净、易于理解，并减少对计算资源的需求。</li></ol></li></ul><p>这样的处理步骤旨在确保数据的质量，为后续建模和分析提供可靠的基础。</p><h1 id="四、-数据特征提取与向量化"><a href="#四、-数据特征提取与向量化" class="headerlink" title="四、 数据特征提取与向量化"></a>四、 <strong>数据特征提取与向量化</strong></h1><blockquote><p><strong>在进行垃圾邮件分类的任务中，文本数据需要被转换为机器学习模型可以处理的数值型数据。这一过程通常包括文本的特征提取和向量化，而我们使用了TF-IDF（Term Frequency-Inverse Document Frequency）向量化方法。</strong></p></blockquote><h2 id="4-1-TF-IDF向量化"><a href="#4-1-TF-IDF向量化" class="headerlink" title="4.1 TF-IDF向量化"></a><strong>4.1 TF-IDF向量化</strong></h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">vectorizer = TfidfVectorizer()</span><br><span class="line">x_train_vectorized = vectorizer.fit_transform(x_train)</span><br><span class="line">x_test_vectorized = vectorizer.transform(x_test)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 对于支持向量机（SVM）等基于数值型数据的机器学习模型，文本数据通常需要经过适当的处理和特征提取才能用于训练和预测。TF-IDF向量化是一种常见的文本特征提取方法，它将文本数据转换为稀疏的数值向量，以便机器学习算法能够理解和处理。TF-IDF考虑了单词在文档中的重要性，降低了常见词汇的权重，增加了罕见词汇的权重。</p><h1 id="五、-模型训练与调优"><a href="#五、-模型训练与调优" class="headerlink" title="五、 模型训练与调优"></a>五、 <strong>模型训练与调优</strong></h1><h2 id="5-1-初始化SVM模型"><a href="#5-1-初始化SVM模型" class="headerlink" title="5.1 初始化SVM模型"></a>5.1 初始化SVM模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">svc = SVC()</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 在这个项目中，我们选择使用支持向量机（SVM）作为分类模型。通过初始化一个SVM分类器，我们为后续的超参数调优和模型训练做好了准备。</p><h2 id="5-2-使用GridSearchCV查找最佳超参数组合"><a href="#5-2-使用GridSearchCV查找最佳超参数组合" class="headerlink" title="5.2 使用GridSearchCV查找最佳超参数组合"></a>5.2 使用GridSearchCV查找最佳超参数组合</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">param_grid = &#123;<span class="string">&#x27;C&#x27;</span>: [<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>], <span class="string">&#x27;kernel&#x27;</span>: [<span class="string">&#x27;linear&#x27;</span>, <span class="string">&#x27;rbf&#x27;</span>], <span class="string">&#x27;gamma&#x27;</span>: [<span class="string">&#x27;scale&#x27;</span>, <span class="string">&#x27;auto&#x27;</span>]&#125;</span><br><span class="line">grid_search = GridSearchCV(svc, param_grid, cv=<span class="number">5</span>, scoring=<span class="string">&#x27;accuracy&#x27;</span>, n_jobs=-<span class="number">1</span>)</span><br><span class="line">grid_search.fit(x_train_vectorized, y_train)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 为了提高模型的性能，我们使用了网格搜索（Grid Search）来搜索最佳的超参数组合。通过定义超参数的范围，GridSearchCV尝试了不同的组合，并使用交叉验证来评估它们的性能。在这里，我们调整了SVM模型的惩罚参数C、核函数（linear或rbf）和gamma参数。</p><h2 id="5-3-使用最佳超参数重新训练SVM模型"><a href="#5-3-使用最佳超参数重新训练SVM模型" class="headerlink" title="5.3 使用最佳超参数重新训练SVM模型"></a>5.3 使用最佳超参数重新训练SVM模型</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">best_svm_gpu = grid_search.best_estimator_</span><br><span class="line">best_svm_gpu.fit(x_train_vectorized, y_train)</span><br></pre></td></tr></table></figure><p><strong>原因：</strong> 确定了最佳超参数组合后，我们使用这些参数重新训练了SVM模型，以便获得更好的性能。</p><h1 id="六、-实验结果分析与总结"><a href="#六、-实验结果分析与总结" class="headerlink" title="六、 实验结果分析与总结"></a>六、 <strong>实验结果分析与总结</strong></h1><h2 id="6-1-在测试集上计算模型评估指标"><a href="#6-1-在测试集上计算模型评估指标" class="headerlink" title="6.1 在测试集上计算模型评估指标"></a>6.1 在测试集上计算模型评估指标</h2><p>为了评估模型的性能，我在测试集上计算了<strong>准确率、精确度</strong>和<strong>召回率</strong>等指标。这些指标提供了对模型在新数据上表现的全面了解。在垃圾邮件分类任务中，准确率衡量了模型正确分类的比例，精确度度量了垃圾邮件被正确分类的比例，召回率则度量了模型找到所有垃圾邮件的能力。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">predictions = best_svm_gpu.predict(x_test_vectorized)</span><br><span class="line">accuracy = accuracy_score(y_test, predictions)</span><br><span class="line">precision = precision_score(y_test, predictions)</span><br><span class="line">recall = recall_score(y_test, predictions)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;准确率: &#x27;</span>, accuracy)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;精确度: &#x27;</span>, precision)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;召回率: &#x27;</span>, recall)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong></p><ul><li>准确率（Accuracy）：98.08%</li><li>精确度（Precision）：97.59%</li><li>召回率（Recall）：98.89%</li></ul><h2 id="6-2-使用自定义输入测试模型"><a href="#6-2-使用自定义输入测试模型" class="headerlink" title="6.2 使用自定义输入测试模型"></a>6.2 使用自定义输入测试模型</h2><p>通过输入一条新的邮件内容进行模型测试，查看模型对未见过的数据的分类预测。</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">pythonCopy code</span><br><span class="line">new_email = <span class="string">&#x27;亲爱的朋友，我有一个很好的投资机会给你！&#x27;</span></span><br><span class="line">new_email_vectorized = vectorizer.transform([new_email])</span><br><span class="line">prediction = best_svm_gpu.predict(new_email_vectorized)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;预测结果:&#x27;</span>, prediction)</span><br></pre></td></tr></table></figure><p><strong>结果：</strong> 模型预测结果为1，即该邮件被分类为垃圾邮件。</p><p><strong>通过以上实验结果，我们可以得出结论：</strong></p><ul><li>模型在测试集上表现良好，具有高准确率（98.08%）和高召回率（98.89%）。</li><li>模型对新的、未见过的邮件数据也能做出有效的分类预测，体现了其泛化能力。</li><li>该垃圾邮件分类系统可以在实际应用中发挥作用，帮助用户过滤垃圾邮件，提升邮件处理效率。</li></ul><p>通过对实验结果的分析，验证了模型的有效性，也为垃圾邮件分类任务提供了可靠的解决方案。在实际应用中，该模型可以作为一个自动化工具，帮助用户识别和处理大量的电子邮件数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;😀 垃圾邮件（Spam）的泛滥成灾一直是电子邮件系统中的一个严峻问题。随着垃圾邮件技术的不断演变，传统的过滤方法逐渐显得力不从心。因此，本项目旨在利用支持向量机（SVM）这一强大的机器学习工具，实现对垃圾邮件的高效分类，为用户提供更清爽、高效的电子邮件体验。&lt;/p&gt;
&lt;h</summary>
      
    
    
    
    
    <category term="数据挖掘" scheme="https://bdta-zky.github.io/tags/%E6%95%B0%E6%8D%AE%E6%8C%96%E6%8E%98/"/>
    
    <category term="SVM" scheme="https://bdta-zky.github.io/tags/SVM/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day20</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day20/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day20/</id>
    <published>2023-12-24T13:59:35.000Z</published>
    <updated>2023-12-24T14:09:56.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-7-startswith"><a href="#4-7-startswith" class="headerlink" title="4.7 startswith"></a><strong>4.7 startswith</strong></h2><p>“startswith”是Python字符串方法之一，用于检查字符串是否以特定的前缀开始。这个方法通常用于条件检查，以确定一个字符串是否以另一个字符串作为前缀。</p><p>这是startswith方法的语法：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.startswith(prefix[, start[, end]]) </span><br></pre></td></tr></table></figure></blockquote><ul><li><code>str</code> 是要检查的字符串。</li><li><code>prefix</code> 是要检查的前缀字符串。</li><li><code>start</code> （可选）是可选的开始搜索的起始位置。</li><li><code>end</code> （可选）是可选的结束搜索的结束位置。</li></ul><p>startswith方法返回一个布尔值，如果字符串以指定的前缀开始，则返回True，否则返回False。</p><p><strong>要求：</strong></p><p>实现函数is startswith，如果字符串source是以substr开头的，则函数返回True,反之返回<br> False</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_startswith</span>(<span class="params">source,substr</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断字符串source是否以substr开头</span></span><br><span class="line"><span class="string">:paramsource:</span></span><br><span class="line"><span class="string">:paramsubstr:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>source<span class="keyword">or</span> <span class="keyword">not</span>substr:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(substr) &gt; <span class="built_in">len</span>(source):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span>index,item<span class="keyword">in</span> <span class="built_in">enumerate</span>(substr):</span><br><span class="line"><span class="keyword">if</span>item!=source[index]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span><span class="comment">#如果for循环不是因为break结束的，就会进⼊到else语句块</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>思路：</strong></p><p>函数首先要判断传入的参数是否合法，这里默认传入的都是字符串，那么我们要需要判断字符串是否有空串的情况<br> 如果substr的长度大于source的长度，直接返回False<br> 从索引0开始，遍历substr,从source上获得相同索引的字符，两者进行比较，只要有一个字符不相同，则可以立即返回False</p><h2 id="4-8-endswith"><a href="#4-8-endswith" class="headerlink" title="4.8 endswith"></a>4.8 endswith</h2><p><code>&quot;endswith&quot;</code>是Python字符串方法之一，用于检查字符串是否以特定的后缀结尾。这个方法通常用于条件检查，以确定一个字符串是否以另一个字符串作为后缀。</p><p>这是<code>endswith</code>方法的语法：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.endswith(suffix[, start[, end]]) </span><br></pre></td></tr></table></figure></blockquote><ul><li><code>str</code> 是要检查的字符串。</li><li><code>suffix</code> 是要检查的后缀字符串。</li><li><code>start</code> （可选）是可选的开始搜索的起始位置。</li><li><code>end</code> （可选）是可选的结束搜索的结束位置。</li></ul><p><code>endswith</code>方法返回一个布尔值，如果字符串以指定的后缀结尾，则返回True，否则返回False。</p><p><strong>要求：</strong></p><p>实现函数is endswith，判断字符串source是否以substr结尾</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_endswith</span>(<span class="params">source,substr</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断字符串source是否以substr结尾</span></span><br><span class="line"><span class="string">:paramsource:</span></span><br><span class="line"><span class="string">:paramsubstr:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>source<span class="keyword">or</span> <span class="keyword">not</span>substr:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(substr) &gt; <span class="built_in">len</span>(source):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">start_index= <span class="built_in">len</span>(source) - <span class="built_in">len</span>(substr)</span><br><span class="line"><span class="keyword">for</span>index<span class="keyword">in</span> <span class="built_in">range</span>(start_index, <span class="built_in">len</span>(source)):</span><br><span class="line"><span class="keyword">if</span>source[index] !=substr[index-start_index]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>思路：</strong></p><p>这个练习题的解法其实和is startswith函数相差无几，所不同的是，在is startswith函数中要从索引0开始进行相同位置字符的比较，而现在，是要判断是否以substr结尾，所以我们从索引len(source) - len(substr)开始逐一进行比较</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-7-startswith&quot;&gt;&lt;a href=&quot;#4-7-startswith&quot; class=&quot;headerlink&quot; title=&quot;4.7 startswith&quot;&gt;&lt;/a&gt;&lt;strong&gt;4.7 startswith&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;“star</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day19</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day19/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day19/</id>
    <published>2023-12-24T13:59:27.000Z</published>
    <updated>2023-12-24T14:09:56.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-4-字符串大写转小写"><a href="#4-4-字符串大写转小写" class="headerlink" title="4.4 字符串大写转小写"></a>4.4 字符串大写转小写</h2><p>在Python中，可以使用<code>lower()</code>方法将字符串中的大写字母转换为小写字母。<code>lower()</code>方法返回一个新的字符串，原始字符串本身不会被修改。</p><p>下面是一个示例：</p><blockquote><p>text = “HELLO, WORLD!”<br>lower_text = text.lower()<br>print(lower_text)  # 输出：hello, world!</p></blockquote><p>在上面的示例中，我们将字符串<code>text</code>中的大写字母转换为小写字母，并将转换后的新字符串赋值给<code>lower_text</code>变量。</p><p>需要注意的是，<code>lower()</code>方法只能将大写字母转换为小写字母，对于已经是小写字母或其他字符的部分，不会有任何影响。</p><p>另外，如果想将字符串中的小写字母转换为大写字母，可以使用**<code>upper()</code>**方法。</p><h2 id="4-5-判断字符串是否全部为小写字母"><a href="#4-5-判断字符串是否全部为小写字母" class="headerlink" title="4.5 判断字符串是否全部为小写字母"></a>4.5 判断字符串是否全部为小写字母</h2><p>在Python中，可以使用<code>islower()</code>方法判断字符串中的所有字母是否都是小写字母。如果字符串中至少有一个非小写字母，<code>islower()</code>方法返回<code>False</code>，否则返回<code>True</code>。</p><p>下面是一个示例：</p><blockquote><p>text1 = “hello, world!”<br>text2 = “Hello, World!”<br>print(text1.islower())  # 输出：True<br>print(text2.islower())  # 输出：False</p></blockquote><p>在上面的示例中，我们分别使用<code>islower()</code>方法判断字符串<code>text1</code>和<code>text2</code>中的所有字母是否都是小写字母。由于<code>text1</code>中的所有字母都是小写字母，因此<code>islower()</code>方法返回<code>True</code>；而<code>text2</code>中包含大写字母，因此<code>islower()</code>方法返回<code>False</code>。</p><p>需要注意的是，<code>islower()</code>方法只能用于判断字符串中的字母是否都是小写字母，对于其他字符，比如数字、标点符号等，不会有任何影响。</p><p>另外，如果想判断字符串中的所有字母是否都是大写字母，可以使用<code>**isupper()**</code>方法。</p><h2 id="4-6-isdigit判断是否只包含数字"><a href="#4-6-isdigit判断是否只包含数字" class="headerlink" title="4.6 isdigit判断是否只包含数字"></a>4.6 isdigit判断是否只包含数字</h2><p>在Python中，可以使用<code>isdigit()</code>方法判断一个字符串是否只包含数字字符。如果字符串中只包含数字字符，<code>isdigit()</code>方法返回<code>True</code>，否则返回<code>False</code>。</p><p>下面是一个示例：</p><blockquote><p>text1 = “12345”<br>text2 = “12.345”<br>print(text1.isdigit())  # 输出：True<br>print(text2.isdigit())  # 输出：False</p></blockquote><p>在上面的示例中，我们分别使用<code>isdigit()</code>方法判断字符串<code>text1</code>和<code>text2</code>是否只包含数字字符。由于<code>text1</code>中只包含数字字符，因此<code>isdigit()</code>方法返回<code>True</code>；而<code>text2</code>中包含小数点，因此<code>isdigit()</code>方法返回<code>False</code>。</p><p>需要注意的是，<code>isdigit()</code>方法只能用于判断字符串中是否只包含数字字符，对于其他字符，比如字母、标点符号等，不会有任何影响。</p><p>另外，如果想判断一个字符串是否只包含字母字符，可以使用<code>isalpha()</code>方法；如果想判断一个字符串是否只包含数字和字母字符，可以使用<code>isalnum()</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-4-字符串大写转小写&quot;&gt;&lt;a href=&quot;#4-4-字符串大写转小写&quot; class=&quot;headerlink&quot; title=&quot;4.4 字符串大写转小写&quot;&gt;&lt;/a&gt;4.4 字符串大写转小写&lt;/h2&gt;&lt;p&gt;在Python中，可以使用&lt;code&gt;lower()&lt;/co</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day18</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day18/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day18/</id>
    <published>2023-12-24T13:59:21.000Z</published>
    <updated>2023-12-24T14:09:56.376Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-字符串方法"><a href="#4-字符串方法" class="headerlink" title="4.字符串方法"></a>4.字符串方法</h1><h2 id="4-1-find"><a href="#4-1-find" class="headerlink" title="4.1 find"></a>4.1 find</h2><p>在Python中，<code>find()</code>方法用于在字符串中查找子字符串，并返回子字符串第一次出现的索引位置。如果找不到子字符串，<code>find()</code>方法返回-1。</p><blockquote><p>str.find(sub, start, end)</p></blockquote><p>其中，<code>str</code>是要搜索的字符串，<code>sub</code>是要查找的子字符串。<code>start</code>和<code>end</code>是可选参数，用于指定搜索的起始和结束位置。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>index = sentence.find(“world”)<br>print(index)  # 输出：7</p></blockquote><p>在上面的示例中，我们在字符串<code>sentence</code>中查找子字符串”world”，并将其第一次出现的索引位置打印出来。</p><p>需要注意的是，<code>find()</code>方法区分大小写。如果要进行不区分大小写的搜索，可以使用<code>lower()</code>或<code>upper()</code>方法将字符串转换为统一的大小写，然后再进行搜索。</p><p>此外，还有其他类似的方法可用于在字符串中查找子字符串，如<code>index()</code>方法和<code>rfind()</code>方法。<code>index()</code>方法与<code>find()</code>方法类似，但如果找不到子字符串，会引发<code>ValueError</code>异常。<code>rfind()</code>方法与<code>find()</code>方法类似，但从字符串的末尾开始搜索子字符串。</p><h2 id="4-2-replace"><a href="#4-2-replace" class="headerlink" title="4.2 replace"></a>4.2 replace</h2><p>在Python中，<code>replace()</code>方法用于替换字符串中的子字符串。</p><p><code>replace()</code>方法的语法如下：</p><blockquote><p>str.replace(old, new, count)</p></blockquote><p>其中，<code>str</code>是要进行替换操作的字符串，<code>old</code>是要被替换的子字符串，<code>new</code>是替换后的新字符串。<code>count</code>是可选参数，用于指定替换的次数。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>new_sentence = sentence.replace(“world”, “Python”)<br>print(new_sentence)  # 输出：Hello, Python!</p></blockquote><p>在上面的示例中，我们将字符串<code>sentence</code>中的子字符串”world”替换为”Python”，并将替换后的新字符串赋值给<code>new_sentence</code>变量。</p><p>需要注意的是，<code>replace()</code>方法返回一个新的字符串，原始字符串本身不会被修改。如果要对原始字符串进行修改，可以将结果重新赋值给原始字符串变量。</p><p>另外，如果不指定<code>count</code>参数，<code>replace()</code>方法会替换所有匹配的子字符串。如果指定了<code>count</code>参数，只会替换前<code>count</code>个匹配的子字符串。</p><h2 id="4-3-split"><a href="#4-3-split" class="headerlink" title="4.3 split"></a>4.3 split</h2><p>在Python中，<code>split()</code>方法用于将字符串分割成多个子字符串，返回一个包含分割后子字符串的列表。</p><p><code>split()</code>方法的语法如下：</p><blockquote><p>str.split(sep, maxsplit)</p></blockquote><p>其中，<code>str</code>是要进行分割操作的字符串，<code>sep</code>是分隔符，默认情况下是空格。<code>maxsplit</code>是可选参数，用于指定最多分割的次数。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>words = sentence.split()<br>print(words)  # 输出：[‘Hello,’, ‘world!’]</p></blockquote><p>在上面的示例中，我们将字符串<code>sentence</code>分割成多个子字符串，以空格为分隔符。由于<code>sentence</code>中只包含两个单词，因此<code>split()</code>方法返回一个包含两个元素的列表。</p><p>需要注意的是，如果不指定分隔符，<code>split()</code>方法会以空格为分隔符。如果指定了分隔符，<code>split()</code>方法会使用指定的分隔符进行分割。</p><p>另外，如果指定了<code>maxsplit</code>参数，<code>split()</code>方法会最多分割<code>maxsplit</code>次。如果不指定<code>maxsplit</code>参数，则会分割所有符合条件的子字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-字符串方法&quot;&gt;&lt;a href=&quot;#4-字符串方法&quot; class=&quot;headerlink&quot; title=&quot;4.字符串方法&quot;&gt;&lt;/a&gt;4.字符串方法&lt;/h1&gt;&lt;h2 id=&quot;4-1-find&quot;&gt;&lt;a href=&quot;#4-1-find&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day17</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day17/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day17/</id>
    <published>2023-12-24T13:59:16.000Z</published>
    <updated>2023-12-24T14:09:56.374Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-9-enumerate"><a href="#3-9-enumerate" class="headerlink" title="3.9 enumerate"></a>3.9 enumerate</h1><p>enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中，下面是使用示例：</p><blockquote><p>lst = [‘a’, ‘b’, ‘c’]</p><p>for index, item in enumerate(lst):</p><p>​    print(index, item)</p></blockquote><p>程序输出：</p><blockquote><p>0 a</p><p>1 b</p><p>2 c</p></blockquote><p><strong>仿造该功能实现下面的函数:</strong></p><blockquote><p>def my_enumerate(lst):</p><p>​    “””</p><p>​    实现和enumerate 类似的功能</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_enumerate(lst):</p><p>​    for i in range(len(lst)):</p><p>​        yield i,lst[i]</p><p>lst = [‘a’,’b’,’c’]</p><p>for index,item in my_enumerage(lst):</p><p>​    print(index,item)</p></blockquote><p><strong>思路：</strong></p><p>这个函数需要对<strong>生成器</strong>有一定的理解和认识。一个函数里出现了<strong>yield关键字</strong>，那么这个函数就是生成器函数，该函数返回的是一个生成器。</p><p>yield和return有着相似的功能，都会将数据返回给调用者，<strong>不同之处在于，return执行后，函数结束了，而yield执行后，会保留当前的状态，等到下一次执行时，恢复之前的状态，继续执行。</strong></p><p>在函数内部，使用for循环通过索引</p><p>遍历lst，使yield返回索引和 索引位置上的元素</p><p><strong>tips：</strong></p><blockquote><p><strong><code>yield</code></strong> 是一个关键字，用于<strong>定义生成器函数</strong>。生成器函数是一种特殊类型的函数，它可以暂停执行并在需要时产生一个值（或一系列值），然后再继续执行。</p><p>当在生成器函数中使用 <code>yield</code> 语句时，它会将一个值返回给调用者，并且当前的函数状态会被保存下来。下次调用生成器函数时，函数会从上次暂停的位置继续执行，而不是从头开始执行。这使得生成器函数能够逐步生成值，而不需要一次性计算和返回所有的值。以下是一个简单的示例，展示了生成器函数的使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">generator = number_generator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过调用 next() 函数获取生成器的下一个值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在上面的示例中，<code>number_generator()</code> 是一个生成器函数，它通过 <code>yield</code> 语句逐步生成数字 1、2 和 3。每次调用 <code>next()</code> 函数时，生成器函数会从上次暂停的位置继续执行，并返回下一个生成的值。</p><p>生成器函数非常有用，特别是在处理大量数据或需要逐步生成结果的情况下。通过使用生成器函数，可以减少内存消耗，并且可以在需要时按需生成值，而不必一次性生成所有的值。</p></blockquote><h1 id="3-10-all"><a href="#3-10-all" class="headerlink" title="3.10 all"></a>3.10 all</h1><p>all()函数用于判断给定的可迭代参数iterable中的所有元素是否都为True，示例代码如下：</p><blockquote><p>lst = [True, False, True]</p><p>print(all(lst))</p></blockquote><p>返回结果为False，实现一个函数，完成类似的功能</p><p><strong>代码：</strong></p><blockquote><p>def my_all(seq):</p><p>​    for item in seq:</p><p>​        if not item:</p><p>​            return False</p><p>​    return True</p></blockquote><p><strong>思路：</strong></p><p>直接用for循环遍历，如果遍历到的元素有False则直接返回False，如果没有是False的，遍历结束返回True</p><h1 id="3-11-any"><a href="#3-11-any" class="headerlink" title="3.11 any"></a>3.11 any</h1><p>any函数用于判断给定的可迭代参数 iterable 中的所有元素是否至少有一个为True</p><blockquote><p>lst = [True, False, False]</p><p>print(any(lst)</p></blockquote><p>返回结果为True，实现一个函数，完成类似功能</p><p><strong>代码：</strong></p><blockquote><p>def my_all(seq):</p><p>​    for item in seq:</p><p>​        if item:</p><p>​            return True</p><p>​    return False</p></blockquote><p><strong>思路：</strong></p><p>类似all，遍历列表，如果有一个是True，则直接返回True，否则则是全不是True，循环结束返回False</p><h1 id="3-12-bin"><a href="#3-12-bin" class="headerlink" title="3.12 bin"></a>3.12 bin</h1><p>函数bin可以获得整数的二进制形式：</p><blockquote><p>print(bin(10))</p></blockquote><p>输出结果为 0b1010</p><p>实现一个函数，完成相同功能，为了降低难度，只需要考虑正整数且不需要在开头加0b</p><p><strong>代码：</strong></p><blockquote><p>def my_bin(value):</p><p>​    lst = []</p><p>​    while value:</p><p>​        if value % 2 == 1:</p><p>​            lst.append(‘1’)</p><p>​        else:</p><p>​            lst.append(‘0’)</p><p>​    value = value // 2  # 也可写成value = value &gt;&gt; 1</p><p>​    </p><p>​    lst = lst[::-1]</p><p>​    return ‘’.join(lst)</p></blockquote><p><strong>思路：</strong></p><ol><li>创建一个空列表 <code>lst</code> 用于存储二进制表示的位。</li><li>进入一个循环，直到 <code>value</code> 的值为 0。</li><li>在循环中，检查 <code>value</code> 是否为奇数（通过取模运算 <code>value % 2 == 1</code>）。如果是奇数，将字符 <code>&#39;1&#39;</code> 添加到列表 <code>lst</code> 中，表示当前位为 1；否则，将字符 <code>&#39;0&#39;</code> 添加到列表 <code>lst</code> 中，表示当前位为 0。</li><li>将 <code>value</code> 的值除以 2（通过整除运算 <code>value // 2</code>），以便在下一次循环中处理下一个位。</li><li>循环结束后，反转列表 <code>lst</code> 的顺序，以得到正确的二进制表示。</li><li>使用 <code>&#39;&#39;.join(lst)</code> 将列表中的字符连接成一个字符串，表示整数的二进制形式。</li><li>返回二进制字符串。</li></ol><p><strong>tips：</strong></p><blockquote><p><strong><code>value = value &gt;&gt; 1</code></strong> 是一个位运算操作，用于将变量 <code>value</code> 的值向右移动一位。</p><p>具体而言，<code>&gt;&gt;</code> 是右移位运算符，它将二进制数向右移动指定的位数。在这种情况下，<code>value</code> 的值被向右移动一位，相当于将其二进制表示的所有位向右移动一位，并将最右边的位丢弃。</p><p>例如，如果 <code>value</code> 的初始值为 10，其二进制表示为 <code>1010</code>。执行 <code>value = value &gt;&gt; 1</code> 后，<code>value</code> 的值将变为 5，其二进制表示为 <code>0101</code>。</p><p>这种右移位操作可以理解为将一个数除以 2（向下取整），因为向右移动一位等于将所有位向右移动一位，并在最左边添加一个零。在二进制中，向右移动一位相当于将数值除以 2。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-9-enumerate&quot;&gt;&lt;a href=&quot;#3-9-enumerate&quot; class=&quot;headerlink&quot; title=&quot;3.9 enumerate&quot;&gt;&lt;/a&gt;3.9 enumerate&lt;/h1&gt;&lt;p&gt;enumerate()函数用于将一个可遍历的数据对象</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day16</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day16/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day16/</id>
    <published>2023-12-24T13:59:07.000Z</published>
    <updated>2023-12-24T14:09:56.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-5-int"><a href="#3-5-int" class="headerlink" title="3.5 int"></a>3.5 int</h1><p>内置函数int，可以将float、全是数字的字符串转换成int类型的数据，为了降低难度，这个练习题只要求你实现其中的一种功能，将全是数字组成的字符串转换成int类型数据，例如将字符此案“123”转换成整数123，函数定义如下：</p><blockquote><p>def my_int(string):</p><p>​    “””</p><p>​    将字符串string转成int类型数据</p><p>​    不考虑string的类型,默认就是符合要求的字符串</p><p>​    传⼊字符串”432”</p><p>​    返回整数432</p><p>​    :param string:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9 }</p><p>def my_int(string):</p><p>​    res = 0</p><p>​    for item in string:</p><p>​        int_value = str_int_dic[item]</p><p>​        res = res*10 + int_value</p><p>​    return res</p></blockquote><p><strong>思路：</strong></p><p>遍历字符串，将每个字符串里的每个字符传换成int类型的数值，这个过程可以使用字典来完成，建立一个字典，字符串的数字做key，int类型的数字做value，例如下面的字典</p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9 }</p></blockquote><p>得到数字后，还得考虑这个数字是哪一位的，是千位还是百位，这里可以使用一个<strong>技巧，遍历的过程都是从左向右进行的，设置一个变量保存转换后的int数据，初始值赋为0，每一次循环后，都用这个变量乘10再加上所遍历的数值，这样就巧妙地解决了位数问题。</strong></p><h1 id="3-6-str"><a href="#3-6-str" class="headerlink" title="3.6 str"></a><strong>3.6 str</strong></h1><p>内置函数str的功能非常强大，想要模仿实现一个相同功能的函数是非常困难的，因此本练习题只要求将int类型的数据转换成字符串，实现下面的函数：</p><blockquote><p>def my_str(int_value):</p><p>​    “””</p><p>​    将int_value转换成字符串</p><p>​    :param int_value:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_str(int_value):</p><p>  if int_value == 0:<br>    return ‘0’</p><p>  lst = []<br>  is_positive = True  #标记是否是负数<br>  if int_value &lt; 0:<br>    is_positive = False<br>    int_value = abs(int_value)</p><p>  while int_value:<br>    number = int_value % 10<br>    int_value //= 10<br>    str_number = chr(number + 48)<br>    lst.append(str_number)</p><p>  if not is_positive:<br>    lst.append(‘-‘)</p><p>  lst = lst[::-1]  #倒序输出<br>  return ‘’.join(lst)</p></blockquote><p><strong>代码详解：</strong></p><blockquote><p>  <strong>if int_value == 0:<br>    return ‘0’</strong></p><p>首先，函数检查输入的整数是否为0。如果是0，那么函数直接返回字符串<code>&#39;0&#39;</code>，表示整数0的字符串形式。</p><p>  <strong>lst = []<br>  is_positive = True<br>  if int_value &lt; 0:<br>    is_positive = False<br>    int_value = abs(int_value)</strong></p><p>接下来，函数创建一个空列表<code>lst</code>，用于存储每个数字的字符形式。同时，函数定义一个布尔变量<code>is_positive</code>，用于表示整数的正负情况。如果输入的整数<code>int_value</code>小于0，说明它是一个负数，那么将<code>is_positive</code>设置为<code>False</code>，并将<code>int_value</code>取绝对值，以便后续处理。</p><p>  <strong>while int_value:<br>    number = int_value % 10<br>    int_value //= 10<br>    str_number = chr(number + 48)<br>    lst.append(str_number)</strong></p><p>接下来是一个循环，用于将整数的每个位数提取出来并转换为字符形式。循环条件是<code>int_value</code>不为0，即还有位数需要处理。在每次循环中，通过取整数<code>int_value</code>除以10的余数，可以得到当前位的数字。然后，将<code>int_value</code>整除以10，以便处理下一位。将数字转换为字符的过程使用了<code>chr()</code>函数，其中<code>number + 48</code>将数字转换为对应的ASCII码。将字符添加到列表<code>lst</code>中。</p><p>  <strong>if not is_positive:<br>    lst.append(‘-‘)<br>  lst = lst[::-1]<br>  return ‘’.join(lst)</strong></p><p>在循环结束后，检查整数的正负情况。如果输入的整数为负数，即<code>is_positive</code>为<code>False</code>，那么在最终的字符串前添加一个负号<code>&#39;-&#39;</code>。然后，将列表<code>lst</code>进行反转操作，以便得到正确的数字顺序。最后，使用<code>&#39;&#39;.join(lst)</code>将列表中的字符连接成一个字符串，并将其作为函数的返回值。</p></blockquote><p>总体来说，这段代码的作用是将整数转换为字符串形式。它通过不断地取整数的每个位数，并将每个位数的字符形式存储在列表中，最后将列表中的字符连接起来，得到整数的字符串表示。</p><p><strong>思路：</strong></p><p>int类型的数据，不能像字符串那样使用for循环进行遍历，但<strong>可以结合/和%操作符从各位向高位进行遍历，获取到某一位的数字之后，将其转换成字符串append到一个列表中。</strong></p><p><strong>遍历结束后，翻转列表，用空字符串join这个列表，即可得到转换后的字符串。</strong></p><p>单个数字，怎样转换成字符串？可以使用3.6中类似的方法， <strong>创建一个字典，数字为key，字符串数字为value</strong></p><blockquote><p>int_str_dict = { 0: ‘0’, 1: ‘1’, 2: ‘2’, 3: ‘3’, 4: ‘4’, 5: ‘5’, 6: ‘6’, 7: ‘7’, 8: ‘8’, 9: ‘9’, }</p></blockquote><p>获得某一位数字之后，通过字典获得对应的字符串，此外，还可以通过ASCII码来获得与之对应的数字字符。以3为例，chr(3+48)即可得到字符串“3”，其原理，字符串3的ASCII码表十进制数值为51，恰好比3大48，其他数值，也同样如此。</p><p>细节性问题：</p><blockquote><p>①如果传入的参数是0，那么直接返回字符串‘0’</p><p>②如果传入的参数是负数，那么需要标识记录，最后在列表里append一个‘-’字符串</p><p>③lst=[1,2,3], 反转 lst=lst[::-1]</p></blockquote><h1 id="3-7-float"><a href="#3-7-float" class="headerlink" title="3.7 float"></a>3.7 float</h1><p>为了降低难度，只要求将字符串转换成float类型的数据，并且字符串都是符合”xx.xx”类型的字符串，例如“34.22”</p><blockquote><p>def my_float(string):</p><p>“””</p><p>将字符串string转换成float类型数据</p><p>:param string:</p><p>:return:</p><p>“””</p><p>pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’:  8, ‘9’: 9}</p><p>def my_float(string):</p><p>​    arrs = string.split(‘.’)</p><p>​    int_value = my_int(arrs[0])    #整数部分</p><p>​    float_value = my_int(arrs[1])  #小数部分</p><p>​    while float_value &gt; 1:</p><p>​        float_value *= 0.1</p><p>​    return int_value + float_value</p></blockquote><p><strong>思路：</strong></p><p>使用<strong>split函数</strong>，可以以”.”作为分隔符，可以将字符串分割为两部分，<strong>整数部分</strong>和<strong>小数部分</strong>，以”34.22”为例，分别得到整数<strong>34</strong>和<strong>22</strong>，对于22，不停的乘以0.1，直到它的数值小于1，就得到了小数部分</p><h1 id="3-8-len"><a href="#3-8-len" class="headerlink" title="3.8 len"></a>3.8 len</h1><p>内置函数len可以获得<strong>可迭代对象</strong>的长度，例如字符串、列表、元组、集合。实现一个类似功能的函数，获得数据的长度。</p><blockquote><p>def my_len(obj):</p><p>​    “””</p><p>​    获得obj对象的⻓度</p><p>​    :param obj:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>from collections import Iterable</p><p>def my_len(obj):</p><p>​    if not isinstance(obj, Iterable):</p><p>​        return None</p><p>​    length = 0</p><p>​    for item in obj:</p><p>​        length += 1</p><p>​    return length</p></blockquote><p><strong>思路：</strong></p><p>使用for循环遍历对象，<strong>循环的次数就是这个对象的长度</strong>，只需要一个变量来保存循环的次数就可以了。</p><p>对obj参数的检查，可以使用<strong>isinstance</strong>判断是否为列表、元组、字典、集合、字符串中的某一个，更为简便的做法就是，这些对象都是<strong>可迭代对象</strong>，<strong>isinstance（obj，lterable）</strong>可以判断obj是否为可迭代对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-5-int&quot;&gt;&lt;a href=&quot;#3-5-int&quot; class=&quot;headerlink&quot; title=&quot;3.5 int&quot;&gt;&lt;/a&gt;3.5 int&lt;/h1&gt;&lt;p&gt;内置函数int，可以将float、全是数字的字符串转换成int类型的数据，为了降低难度，这个练习题只</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day15</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day15/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day15/</id>
    <published>2023-12-24T13:59:01.000Z</published>
    <updated>2023-12-24T14:09:56.372Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-内置函数篇"><a href="#3-内置函数篇" class="headerlink" title="3.内置函数篇"></a>3.内置函数篇</h1><h1 id="3-1-abs"><a href="#3-1-abs" class="headerlink" title="3.1 abs"></a>3.1 abs</h1><p>abs函数返回数字的绝对值，请实现下面的函数，模仿abs函数的功能，返回数字的绝对值</p><blockquote><p>def my_abs(number):</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_abs(number):</p><p>​    if not isinstance(number, (float, int)):</p><p>​         return number</p><p>​    if number &lt; 0:</p><p>​        number *= -1</p><p>​    return numbe</p></blockquote><p><strong>思路：</strong></p><blockquote><p>处于<strong>程序健壮性</strong>考虑，要对传入的number参数进行检查，判断其类型是否为数字类型，float和int是比较常用的数据类型，复数类型基本接触不到，因此不考虑。<br><strong>判断变量类型</strong>，可以使用<strong>isinstance</strong>函数，该函数的第一个参数是需要检查类型的对象，第二个参数可以是数据类型，也可以是一个元组，元组里是多个数据类型，只要满足其中一个就返True<br>如果number的数值小于0，乘以-1就得到了绝对值</p></blockquote><h1 id="3-2-sum"><a href="#3-2-sum" class="headerlink" title="3.2 sum"></a>3.2 sum</h1><p>sum函数可以获取列表所有数据的综合，模仿这个功能实现下面的函数</p><blockquote><p>def my_sum(lst):</p><p>​    “””</p><p>​    返回列表⾥所有数据的总和</p><p>​    如果列表⾥有⾮数字类型的数据，忽略不管</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_sum(lst):</p><p>sum_res = 0</p><p>if not isinstance(lst, list):</p><p>​    return sum_res</p><p>for item in lst:</p><p>​    if isinstance(item, (float, int)):</p><p>​        sum_res += item</p><p>return sum_res</p></blockquote><p><strong>思路：</strong></p><blockquote><p>①对传入的参数lst，要进行类型检查</p><p>②遍历列表，遇到数字类型的数据就进行加和操作</p></blockquote><h1 id="3-3-max"><a href="#3-3-max" class="headerlink" title="3.3 max"></a>3.3 max</h1><p>max函数返回序列中的最大值，传入的参数可以是列表，也可以是元组，实现下面的函数，实现同样的功能，如果序列里有非数字类型的数据，可以忽略，如果序列是空的，可以直接返回None</p><blockquote><p>def my_max(seq):</p><p>​    “””</p><p>​    返回序列⾥的最⼤值</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_max(seq):</p><p>​    max_value=None</p><p>​    if not isinstance(seq,(list,tuple)):</p><p>​        return max_value</p><p>​    if len(seq)=0:</p><p>​        return max_value</p><p>​    max_value=seq[0]</p><p>​    for item in seq:</p><p>​        if not isinstance(item,(int,float)):</p><p>​            continue</p><p>​        if item&gt;max_value:</p><p>​            item=max_value</p><p>​    return max_value</p></blockquote><p><strong>思路：</strong></p><blockquote><p>①对传入的参数seq需要进行类型检查，如果既不是列表也不是元组，那么就返回None</p><p>②如果序列是空的，也直接返回None</p><p>③ 遍历序列中的元素，如果数据的类型不属于数字类型，那么就忽略跳过</p></blockquote><h1 id="3-4-min"><a href="#3-4-min" class="headerlink" title="3.4 min"></a>3.4 min</h1><p>min函数返回序列中的最小值，传入的参数可以是列表，也可以是元组，实现下面的函数，实现同样的功能，如果序列里又非数字类型的数据，可以忽略</p><blockquote><p>def my_min(seq):</p><p>​    “””</p><p>​    返回序列⾥的最⼩值</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码（与max类似）：</strong></p><blockquote><p>def my_min(seq):</p><p>​    min_value=None</p><p>​    if not isinstance(seq,(list,tuple)):</p><p>​        return min_value</p><p>​    if len(seq)=0:</p><p>​        return min_value</p><p>​    min_value=seq[0]</p><p>​    for item in seq:</p><p>​        if not isinstance(item,(int,float)):</p><p>​            continue</p><p>​        if item&lt;min_value:</p><p>​            item=min_value</p><p>​    return min_value</p></blockquote><p><strong>思路（与max一致）：</strong></p><blockquote><p>①对传入的参数seq需要进行类型检查，如果既不是列表也不是元组，那么就返回None</p><p>②如果序列是空的，也直接返回None</p><p>③ 遍历序列中的元素，如果数据的类型不属于数字类型，那么就忽略跳过</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-内置函数篇&quot;&gt;&lt;a href=&quot;#3-内置函数篇&quot; class=&quot;headerlink&quot; title=&quot;3.内置函数篇&quot;&gt;&lt;/a&gt;3.内置函数篇&lt;/h1&gt;&lt;h1 id=&quot;3-1-abs&quot;&gt;&lt;a href=&quot;#3-1-abs&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day14</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day14/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day14/</id>
    <published>2023-12-24T13:58:55.000Z</published>
    <updated>2023-12-24T14:09:56.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="③continue的好处"><a href="#③continue的好处" class="headerlink" title="③continue的好处"></a>③continue的好处</h1><p><strong>break是跳出循环体，continue是跳过continue语句后面的代码块，循环并不停止</strong><br>题目要求:<br>使用input函数接受用户的输入，如果用户输入的数值小于等于10，则判断是奇数还是偶数如果数值大于10，则输出“输入大于10，不判断奇偶”,用户输入quit，结束程序</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数,如果想停⽌程序，输⼊quit:”)</p><p>​    if input_str == ‘quit’:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number &gt; 10:</p><p>​        print(“输入大于10，不判断奇偶”)</p><p>​        continue</p><p>​    if number % 2 == 0:</p><p>​        print(“输⼊为偶数”)</p><p>​    else:</p><p>​        print(“输⼊为奇数”)</p></blockquote><p>当number大于10 的时候，后面的那4行代码就不会被执行，直接进入到下一次循环上面的代码，也可以不使用continue</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数,如果想停⽌程序，输⼊quit:”)</p><p>​    if input_str == ‘quit’:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number &lt; 10:</p><p>​        if number % 2 == 0:</p><p>​            print(“输⼊为偶数”)</p><p>​        else:</p><p>​            print(“输⼊为奇数”)</p></blockquote><p>两段代码，实现了一样的功能，但对比一下不难发现，<strong>不使用continue，代码的嵌套层次更深</strong>，如果嵌套多了，会让代码变得难以阅读，难以管理<br>但使用continue，就可以减少代码层次，代码的理解和管理都更容易，大于10的时候continue跳过后面的代码，在逻辑思考时，这种一刀两断的方法让思路更清晰.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;③continue的好处&quot;&gt;&lt;a href=&quot;#③continue的好处&quot; class=&quot;headerlink&quot; title=&quot;③continue的好处&quot;&gt;&lt;/a&gt;③continue的好处&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;break是跳出循环体，continue是跳</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day13</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day13/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day13/</id>
    <published>2023-12-24T13:58:50.000Z</published>
    <updated>2023-12-24T14:09:56.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-3-while循环"><a href="#2-3-while循环" class="headerlink" title="2.3 while循环"></a>2.3 while循环</h1><h2 id="①奇偶数判断"><a href="#①奇偶数判断" class="headerlink" title="①奇偶数判断"></a>①奇偶数判断</h2><p>使用input函数接收用户输入的整数，如果是偶数，则使用print函数输出”你输入的是一个偶数”,反之输出”你输入的是一个奇数”，用户可以输入多次，直到输入quit时程序退出</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数，想退出程序请输⼊ quit:”)</p><p>​    if input_str == “quit”:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number % 2 == 0:</p><p>​        print(“你输⼊的是⼀个偶数”)</p><p>​    else:</p><p>​        print(“你输⼊的是⼀个奇数”)</p></blockquote><h2 id="②for循环与while循环嵌套"><a href="#②for循环与while循环嵌套" class="headerlink" title="②for循环与while循环嵌套"></a>②for循环与while循环嵌套</h2><p>已知 lst = [2, 3, 4]依次要求用户输入2，3，4 的整数倍，先让用户输入2的倍数，如果用户输入的正确，输出“输入正确”，否则输出“输入错误”，如果用户输入quit，则停止当前的输入，让用户输入3的倍数，输入3的倍数的过程中，如果用户输入quit，则让用户输入4的倍数</p><blockquote><p>lst = [2, 3, 4]</p><p>for item in lst:</p><p>​    while True:</p><p>​        input_str = input(“请输⼊{number}的倍数,想停⽌输⼊时，输⼊quit:”.format(numbe r=item))</p><p>​        if input_str == ‘quit’:</p><p>​            break</p><p>​        number = int(input_str)</p><p>​        if number % item == 0:</p><p>​            print(“输⼊正确”)</p><p>​        else:</p><p>​            print(“输⼊错误”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-3-while循环&quot;&gt;&lt;a href=&quot;#2-3-while循环&quot; class=&quot;headerlink&quot; title=&quot;2.3 while循环&quot;&gt;&lt;/a&gt;2.3 while循环&lt;/h1&gt;&lt;h2 id=&quot;①奇偶数判断&quot;&gt;&lt;a href=&quot;#①奇偶数判断&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day12</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day12/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day12/</id>
    <published>2023-12-24T13:58:45.000Z</published>
    <updated>2023-12-24T14:09:56.369Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⑥寻找列表中的最大值，最小值"><a href="#⑥寻找列表中的最大值，最小值" class="headerlink" title="⑥寻找列表中的最大值，最小值"></a>⑥寻找列表中的最大值，最小值</h1><blockquote><p>lst = [3, 6, 1, 8, 1, 9 , 2]</p><p>max_value = lst[0]</p><p>​    for item in lst:</p><p>​        if item &gt; max_value:</p><p>​        max_value = item</p><p>print(max_value) </p></blockquote><p>1.参照上面的代码，写代码寻找列表的最小值</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>min_value = lst[0]</p><p>for item in lst:<br>  if item &lt; min_value:<br>    min_value = item</p><p>print(min_value)</p></blockquote><p>2.写代码寻找列表里的最小偶数</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>min_even = None</p><p>for item in lst:<br>  if item % 2 == 0:<br>    if min_even is None or item &lt; min_even:<br>      min_even = item</p><p>print(min_even)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>min_even</code> 来保存最小的偶数。初始值设置为 <code>None</code>，表示还没有找到偶数。然后，我们遍历列表中的每个元素，如果遇到偶数，则检查是否比当前的 <code>min_even</code> 更小，如果是，则更新 <code>min_even</code>。最终，输出 <code>min_even</code> 即为列表中的最小偶数。</strong></p><p>3.写代码寻找列表里的最大奇数</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>max_odd = None</p><p>for item in lst:<br>  if item % 2 != 0:<br>    if max_odd is None or item &gt; max_odd:<br>      max_odd = item</p><p>print(max_odd)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>max_odd</code> 来保存最大的奇数。初始值同样设置为 <code>None</code>，表示还没有找到奇数。然后，我们遍历列表中的每个元素，如果遇到奇数，则检查是否比当前的 <code>max_odd</code> 更大，如果是，则更新 <code>max_odd</code>。最终，输出 <code>max_odd</code> 即为列表中的最大奇数。</strong></p><p><strong>请注意，如果列表中没有奇数，那么输出结果将为 <code>None</code>，表示没有找到最大奇数。</strong></p><h1 id="⑦寻找组合"><a href="#⑦寻找组合" class="headerlink" title="⑦寻找组合"></a><strong>⑦寻找组合</strong></h1><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9 , 2]</p><p>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>for item1 in lst1:</p><p>​    for item2 in lst2:</p><p>​        if item1 + item2 == 10:</p><p>​            print((item1, item2))</p></blockquote><p><strong>上面的代码利用嵌套循环，从两个列表里各取1个数，如果这两个数的和等于10，则以元组的方式输出这两个数</strong></p><p>1.参照上面的代码，寻找两个数的差的绝对值等于2的组合</p><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9, 2]<br>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>for item1 in lst1:<br>  for item2 in lst2:<br>    if abs(item1 - item2) == 2:<br>      print((item1, item2))</p></blockquote><p>2.两个列表里各取出一个值，item1和item2， 请计算item1*item2的最大值</p><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9, 2]<br>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>max_product = float(‘-inf’)</p><p>for item1 in lst1:<br>  for item2 in lst2:<br>    product = item1 * item2<br>    if product &gt; max_product:<br>      max_product = product</p><p>print(max_product)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>max_product</code> 来保存最大的乘积。初始值设置为负无穷 <code>-inf</code>，确保任何乘积都会比它大。然后，我们使用嵌套循环遍历 <code>lst1</code> 和 <code>lst2</code> 中的元素，计算 <code>item1 \* item2</code> 的乘积，并与当前的 <code>max_product</code> 进行比较，如果大于 <code>max_product</code>，则更新 <code>max_product</code>。最终，输出 <code>max_product</code> 即为 <code>item1 \* item2</code> 的最大值。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⑥寻找列表中的最大值，最小值&quot;&gt;&lt;a href=&quot;#⑥寻找列表中的最大值，最小值&quot; class=&quot;headerlink&quot; title=&quot;⑥寻找列表中的最大值，最小值&quot;&gt;&lt;/a&gt;⑥寻找列表中的最大值，最小值&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;lst = [3,</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day11</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day11/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day11/</id>
    <published>2023-12-24T13:58:39.000Z</published>
    <updated>2023-12-24T14:09:56.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="④continue练习"><a href="#④continue练习" class="headerlink" title="④continue练习"></a>④continue练习</h1><p>从列表 Ist = [1,3,5,2,7,9,10] 中输出所有的奇数，代码如下</p><blockquote><p>lst = [1, 3, 5, 2, 7, 9, 10]</p><p>for item in lst:<br>  if item % 2 == 0:<br>    continue<br>  print(item)</p></blockquote><p>在上述代码中，当遇到偶数时，<code>continue</code> 语句会跳过当前迭代，直接进入下一次迭代。因此，只有奇数会被输出。</p><p>请注意，<code>continue</code> 语句后面的代码将不会被执行，而是直接进入下一次迭代。在这个例子中，当遇到偶数时，<code>print(item)</code> 这行代码将被跳过。</p><h1 id="⑤break练习"><a href="#⑤break练习" class="headerlink" title="⑤break练习"></a>⑤break练习</h1><p>从列表 Ist = [1,3,5,2,7,9,10] 中寻找1个偶数并输出，代码如下</p><blockquote><p>lst = [1, 3, 5, 2, 7, 9, 10]</p><p>for item in lst:</p><p>​    if item % 2 == 0:</p><p>​        print(item)</p><p>​        break</p></blockquote><p>题目要求寻找一个偶数，当找到这个偶数后，循环就可以终止了，使用break可以终止本次循环，你可以去掉代码中的break，再次执行代码，观察代码的执行效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;④continue练习&quot;&gt;&lt;a href=&quot;#④continue练习&quot; class=&quot;headerlink&quot; title=&quot;④continue练习&quot;&gt;&lt;/a&gt;④continue练习&lt;/h1&gt;&lt;p&gt;从列表 Ist = [1,3,5,2,7,9,10] 中输出所有的奇</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day10</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day10/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day10/</id>
    <published>2023-12-24T13:58:34.000Z</published>
    <updated>2023-12-24T14:09:56.368Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-2-for循环"><a href="#2-2-for循环" class="headerlink" title="2.2 for循环"></a>2.2 for循环</h1><h1 id="①range函数的基本使用"><a href="#①range函数的基本使用" class="headerlink" title="①range函数的基本使用"></a>①range函数的基本使用</h1><blockquote><p>range(3, 20, 4)</p><p>range(10, -3, -4)</p><p>range(10, 5)</p><p>range(2, 12)</p></blockquote><p>不使用代码，说出以上函数产生的整数序列</p><p><strong>解答：</strong></p><blockquote><ol><li><code>range(3, 20, 4)</code>：这个函数调用将返回一个从3开始，以4为步长递增的序列，直到小于20为止。结果为 <code>[3, 7, 11, 15, 19]</code>。</li><li><code>range(10, -3, -4)</code>：这个函数调用将返回一个从10开始，以-4为步长递减的序列，直到大于-3为止。结果为 <code>[10, 6, 2, -2]</code>。</li><li><code>range(10, 5)</code>：这个函数调用将返回一个从10开始，以1为步长递减的序列，直到大于5为止。结果为空序列，因为起始值大于结束值。</li><li><code>range(2, 12)</code>：这个函数调用将返回一个从2开始，以1为步长递增的序列，直到小于12为止。结果为 <code>[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</code>。</li></ol></blockquote><p><strong>请注意</strong>，<code>range()</code>函数返回的是一个迭代器对象，如果需要将其转换为列表，可以使用<code>list()</code>函数进行转换。</p><h1 id="②利用range函数遍历列表"><a href="#②利用range函数遍历列表" class="headerlink" title="②利用range函数遍历列表"></a>②利用range函数遍历列表</h1><blockquote><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for index in range(len(lst)):</p><p>​    print(lst[index])</p></blockquote><p>1.参照上面的代码，从后向前遍历</p><p>2.遍历输出列表里的所有偶数</p><p>3.遍历列表，输出大于3的奇数</p><p><strong>解答：</strong></p><blockquote><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for index in range(len(lst)-1, -1, -1):<br>  print(lst[index])</p></blockquote><p>这段代码使用<code>range()</code>函数从<code>len(lst)-1</code>开始，以-1为步长递减，实现了从后向前遍历列表。</p><blockquote><p>(使用range）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for i in range(len(list)):<br>  num = list[i]<br>  if num % 2 == 0:<br>    print(“偶数:”, num)<br>  elif num % 2 == 1 and num &gt; 3:<br>    print(“大于3的奇数:”, num)</p></blockquote><blockquote><p>（未使用range 简便版）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for num in lst:<br>  if num % 2 == 0:<br>    print(num)</p></blockquote><p>这段代码遍历列表中的每个元素，通过判断元素是否为偶数，输出所有偶数。</p><blockquote><p>（使用range）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for i in range(len(lst)):<br>  num = lst[i]<br>  if num &gt; 3 and num % 2 != 0:<br>    print(num)</p></blockquote><blockquote><p>（未使用range简便版）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for num in lst:<br>  if num &gt; 3 and num % 2 != 0:<br>    print(num)</p></blockquote><p>这段代码遍历列表中的每个元素，通过判断元素是否大于3且为奇数，输出所有满足条件的元素。</p><h1 id="③使用for循环遍历字典"><a href="#③使用for循环遍历字典" class="headerlink" title="③使用for循环遍历字典"></a>③使用for循环遍历字典</h1><p><strong>1.仅遍历key值</strong></p><blockquote><p>dic = { ‘python’: 90, ‘java’: 95 }</p><p>for key in dic:</p><p>​    print(key, dic[key])</p></blockquote><p><strong>2.遍历key和value值</strong></p><blockquote><p>dic = { ‘python’: 90, ‘java’: 95 } for</p><p>key, value in dic.items():</p><p>​    print(key, value)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-2-for循环&quot;&gt;&lt;a href=&quot;#2-2-for循环&quot; class=&quot;headerlink&quot; title=&quot;2.2 for循环&quot;&gt;&lt;/a&gt;2.2 for循环&lt;/h1&gt;&lt;h1 id=&quot;①range函数的基本使用&quot;&gt;&lt;a href=&quot;#①range函数的基本使</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day09</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day09/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day09/</id>
    <published>2023-12-24T13:58:27.000Z</published>
    <updated>2023-12-24T14:09:56.366Z</updated>
    
    <content type="html"><![CDATA[<h1 id="③多条件分支"><a href="#③多条件分支" class="headerlink" title="③多条件分支"></a>③多条件分支</h1><p>使用input函数接收用户的输入数据，如果用户输入python，则输出90，如果用户输入java.输出95，如果用户输入php，输出85，其他输入，程序输出0</p><p><strong>解答：</strong></p><p><strong>if…elif…else</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>if value == ‘python’:</p><p>​    print(90)</p><p>elif value == ‘java’:</p><p>​    print(95)</p><p>elif value == ‘php’:</p><p>​    print(85)</p><p>else:</p><p>​    print(0)</p></blockquote><p><strong>程序流程图：</strong></p><p><img src="https://s11.ax1x.com/2023/12/24/piHKaMF.png"></p><p><strong>在Python 3.9以及之前的版本中，并没有提供真正意义上的多分支选择结构，如果确实需要可通过字典构造跳转表来实现，如下代码：</strong></p><blockquote><p>user_input = input(“请输入编程语言：”)</p><p>score_dict = {<br>  “python”: 90,<br>  “java”: 95,<br>  “php”: 85<br>}</p><p>score = score_dict.get(user_input, 0)<br>print(score)</p></blockquote><p><strong>Python 3.10新增了软关键字（只在特定场合作为关键字，普通场合也可以作为变量名）match和case，实现了真正意义上的多分支选择结构。</strong></p><p><strong>【类似c和java中的switch…case…】</strong></p><blockquote><p><strong>user_input = input(“请输入编程语言：”)</strong></p><p><strong>match user_input:<br>  case “python”:<br>    print(90)<br>  case “java”:<br>    print(95)<br>  case “php”:<br>    print(85)<br>  case _:<br>    print(0)</strong></p></blockquote><h1 id="④复杂条件判断"><a href="#④复杂条件判断" class="headerlink" title="④复杂条件判断"></a>④复杂条件判断</h1><p>使用input函数接收用户的输入，如果输入的数据不可以转换成int类型数据，则输出”无法使用<br>int函数转换”，如果可以，则将用户的输入转成int类型数据并继续判断。</p><p>如果输入数据是奇数，则将其乘以2并输出，如果是偶数，则判断是否能被4整除，如果可以则输出被4整除后的值，若不能被4整数，则判断是否大于20，如果大于20则输出与20的差值，如果小于等于20，则直接输出该值</p><p><strong>解答：</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>if not value.isdigit():</p><p>​    print(‘⽆法使⽤int函数转换’)</p><p>else:</p><p>​    i_value = int(value)</p><p>​    if i_value % 2 == 1:</p><p>​        print(i_value*2)</p><p>​    elif i_value % 4 == 0:</p><p>​        print(i_value / 4)</p><p>​    elif i_value &gt; 20:</p><p>​        print(i_value - 20)</p><p>​    else:</p><p>​        print(i_value</p></blockquote><p><strong>程序流程图：</strong></p><p><img src="https://s11.ax1x.com/2023/12/24/piHKwqJ.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;③多条件分支&quot;&gt;&lt;a href=&quot;#③多条件分支&quot; class=&quot;headerlink&quot; title=&quot;③多条件分支&quot;&gt;&lt;/a&gt;③多条件分支&lt;/h1&gt;&lt;p&gt;使用input函数接收用户的输入数据，如果用户输入python，则输出90，如果用户输入java.输出95，</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day08</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day08/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day08/</id>
    <published>2023-12-24T13:58:22.000Z</published>
    <updated>2023-12-24T14:09:56.364Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-基础语法篇"><a href="#2-基础语法篇" class="headerlink" title="2.基础语法篇"></a>2.基础语法篇</h1><h1 id="2-1-if-条件句"><a href="#2-1-if-条件句" class="headerlink" title="2.1 if 条件句"></a>2.1 if 条件句</h1><h1 id="①单个条件分支"><a href="#①单个条件分支" class="headerlink" title="①单个条件分支"></a>①单个条件分支</h1><p>使用input函数接收用户的输入，如果用户输入的整数是偶数，则使用print函数输出”你输入的整数是:{value],它是偶数”，[value]部分要替换成用户的输入。</p><p><strong>解答:</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>i_value = int(value)</p><p>if i_value % 2 == 0:</p><p>​    print(“你输⼊的整数是:{value}, 它是偶数”.format(value=value))</p></blockquote><p><strong>完成这个练习题需要掌握的4个知识点</strong><br>1.input函数的作用<br>2.字符串转int<br>3.取模运算<br>4.字符串格式化</p><h1 id="②-if…else…"><a href="#②-if…else…" class="headerlink" title="② if…else…"></a>② if…else…</h1><p>使用input函数接收用户的输入，如果用户输入的整数是偶数，则使用print函数输出”你输入的整数是:{value],它是偶数”,如果是奇数，则使用print函数输出”你输入的整数是:value],它是奇数”</p><p><strong>解答:</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>i_value = int(value)</p><p>if i_value % 2 == 0:</p><p>​    print(“你输⼊的整数是:{value}, 它是偶数”.format(value=value))</p><p>else:</p><p>​    print(“你输⼊的整数是:{value}, 它是奇数”.format(value=value))</p></blockquote><p><strong>程序流程图</strong></p><p><img src="/C:/Users\liuduo\Desktop\blog\source_posts\assets\piHK85q.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-基础语法篇&quot;&gt;&lt;a href=&quot;#2-基础语法篇&quot; class=&quot;headerlink&quot; title=&quot;2.基础语法篇&quot;&gt;&lt;/a&gt;2.基础语法篇&lt;/h1&gt;&lt;h1 id=&quot;2-1-if-条件句&quot;&gt;&lt;a href=&quot;#2-1-if-条件句&quot; class=&quot;head</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day07</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day07/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day07/</id>
    <published>2023-12-24T13:58:15.000Z</published>
    <updated>2023-12-24T14:09:56.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-5集合练习题"><a href="#1-5集合练习题" class="headerlink" title="1.5集合练习题"></a>1.5集合练习题</h1><p>集合间的运算</p><blockquote><p>lst1 = [1, 2, 3, 5, 6, 3, 2]</p><p>lst2 = [2, 5, 7, 9]</p></blockquote><ul><li>哪些整数既在Ist1中，也在Ist2中</li><li>哪些整数在Ist1中，不在Ist2中</li><li>两个列表一共有哪些整数</li></ul><p>虽然题目问的是两个列表之间的问题，但是用列表解答的效率很低，所以应该用集合</p><blockquote><p>lst1 = [1, 2, 3, 5, 6, 3, 2]</p><p>lst2 = [2, 5, 7, 9]</p><p>set1 = set(lst1)</p><p>set2 = set(lst2)</p><p># 哪些整数既在lst1中，也在lst2中</p><p>print(set1.intersection(set2))</p><p># 哪些整数在lst1中，不在lst2中</p><p>print(set1.difference(set2))</p><p># 两个列表⼀共有哪些整数</p><p>print(set1.union(set2)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-5集合练习题&quot;&gt;&lt;a href=&quot;#1-5集合练习题&quot; class=&quot;headerlink&quot; title=&quot;1.5集合练习题&quot;&gt;&lt;/a&gt;1.5集合练习题&lt;/h1&gt;&lt;p&gt;集合间的运算&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lst1 = [1, 2, 3, 5,</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day06</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day06/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day06/</id>
    <published>2023-12-12T11:05:09.000Z</published>
    <updated>2023-12-12T11:06:27.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4字典练习题"><a href="#1-4字典练习题" class="headerlink" title="1.4字典练习题"></a>1.4字典练习题</h1><h1 id="①字典基本操作"><a href="#①字典基本操作" class="headerlink" title="①字典基本操作"></a>①字典基本操作</h1><blockquote><p>dic = { ‘python’: 95, ‘java’: 99, ‘c’: 100 }</p></blockquote><p><strong>用程序解答以下题目</strong></p><blockquote><p>1.字典的长度是多少<br>2.请修改java’这个key对应的value值为98<br>3.删除 c 这个key<br>4.增加一个key-value对，key值为 php,value是90<br>5.获取所有的key值，存储在列表里<br>6.获取所有的value值，存储在列表里</p><p>7.判断 javascript 是否在字典中<br>8.获得字典里所有value 的和<br>9.获取字典里最大的value</p><p>10.获取字典里最小的value<br>11.字典 dic1 = [php’: 97],将dic1的数据更新到dic中</p></blockquote><p><strong>解答：</strong></p><blockquote><p>第1题，len(dic),结果为3<br>第2题，dic[java] = 98,对字典里value的修改，必须通过key才可以<br>第3题，del dic[‘c]<br>第4题，dic[php] = 90<br>第5题，lst = list(dic.keys())<br>第6题，lst = list(dic.values())<br>第7题，javascript’ in dic<br>第8题，sum(dic.values()<br>第9题，max(dic.values())<br>第10题，min(dic.values())<br>第11题，dic.update(dic1)</p></blockquote><h1 id="②字典应用"><a href="#②字典应用" class="headerlink" title="②字典应用"></a><strong>②字典应用</strong></h1><p><strong>小明去超市购买水果，账单如下 ：</strong></p><blockquote><p>苹果 32.8</p><p>⾹蕉 22</p><p>葡萄 15.5</p></blockquote><p>请将上面的数据存储到字典里，可以根据水果名称查询购买这个水果的费用</p><p><strong>解答：</strong></p><blockquote><p>info = { ‘苹果’:32.8, ‘⾹蕉’: 22,’葡萄’:15.5}</p></blockquote><p>直接用水果名字做key，价格做value</p><h1 id="③字典应用（买水果2）"><a href="#③字典应用（买水果2）" class="headerlink" title="③字典应用（买水果2）"></a>③字典应用（买水果2）</h1><p>小明，小刚去超市里购买水果<br>小明购买了苹果，草莓，香蕉，一共花了89块钱，小刚购买了葡萄，橘子，樱桃，一共花了87块钱<br><strong>请从上面的描述中提取数据，存储到字典中，可以根据姓名获取这个人购买的水果种类和总费用。</strong></p><p><strong>解答：</strong></p><blockquote><p>info = {</p><p>​    ‘⼩明’: {</p><p>​        ‘fruits’: [‘苹果’, ‘草莓’, ‘⾹蕉’],</p><p>​        ‘money’: 89</p><p>​    },</p><p>​    ‘⼩刚’: {</p><p>​        ‘fruits’: [‘葡萄’, ‘橘⼦’, ‘樱桃’],</p><p>​        ‘money’: 87</p><p>​    }</p><p>}</p></blockquote><p><strong>以姓名做key，value仍然是字典</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4字典练习题&quot;&gt;&lt;a href=&quot;#1-4字典练习题&quot; class=&quot;headerlink&quot; title=&quot;1.4字典练习题&quot;&gt;&lt;/a&gt;1.4字典练习题&lt;/h1&gt;&lt;h1 id=&quot;①字典基本操作&quot;&gt;&lt;a href=&quot;#①字典基本操作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day05</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day05/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day05/</id>
    <published>2023-09-18T12:00:09.000Z</published>
    <updated>2023-10-17T09:08:16.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⑤合并字符串"><a href="#⑤合并字符串" class="headerlink" title="⑤合并字符串"></a>⑤合并字符串</h1><blockquote><p>str1=“1，2，3”</p><p>str2=“4，5，6”</p></blockquote><p>请将str1合并到str2的末尾，并思考这个过程中，是否产生了新的字符串</p><p><strong>解答：</strong></p><blockquote><p>str1 += str2</p></blockquote><p>这个过程中，产生的新的字符串，字符串是不可变对象，从字面意义上理解，似乎str1的内容发生变化了， 但本质上是产生了新的字符串并赋值给str1，print（str1），合并前后的内存地址是不一样的。</p><h1 id="⑥统计练习"><a href="#⑥统计练习" class="headerlink" title="⑥统计练习"></a>⑥统计练习</h1><blockquote><p>lst = [2,5,6,7,8,9,2,9,9]</p></blockquote><p><strong>请写程序完成下列题目：</strong></p><blockquote><p>1.找出列表里的最大值</p><p>2.找出列表里的最小值</p><p>3.找出列表里最大值的个数</p><p>4.计算列表里所有元素的和</p><p>5.计算列表里元素的平均值</p><p>6.计算列表的长度</p><p>7.找出元素6在列表中的索引</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. max(lst)</p><p>\2. min(lst)</p><p>\3. lst.count(max(lst))</p><p>\4. sum(lst)</p><p>\5. sum(lst)/float(len(lst))</p><p>\6. len(lst)</p><p>\7. lst.index(6)</p></blockquote><p><strong>第五题解析：</strong></p><blockquote><ul><li><code>sum(lst)</code>：这个部分是用来计算列表 <code>lst</code> 中所有元素的总和。</li><li><code>len(lst)</code>：这个部分是用来计算列表 <code>lst</code> 的长度，即列表中元素的个数。</li><li><code>float(len(lst))</code>：这个部分是将列表的长度转换为浮点数类型，以确保在进行除法运算时得到的结果是浮点数。</li><li><code>sum(lst)/float(len(lst))</code>：这个部分将列表的总和除以列表的长度，得到的结果就是列表元素的平均值。</li></ul><p><strong>这部分题考察的是对内置函数的理解和应用</strong></p></blockquote><p><strong>下面的题目不写代码，仅凭思考来回答</strong></p><blockquote><p>1.lst[2:4]的值是什么</p><p>2.lst[1: -3]的值是什么</p><p>3.lst[-5]的值是什么</p><p>4.lst[:-4] 的值是什么</p><p>5.lst[-4:] 的值是什么</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. [6, 7]</p><p>\2. [5, 6, 7, 8, 9]</p><p>\3. 8</p><p>\4. [2, 5, 6, 7, 8]</p><p>\5. [9, 2, 9, 9]</p></blockquote><p>列表的切片操作，一定要记住<strong>左闭右开</strong></p><p><strong>注意第三和第四个的区别，少一个符号的区别很大</strong></p><h1 id="⑦列表操作练习"><a href="#⑦列表操作练习" class="headerlink" title="⑦列表操作练习"></a><strong>⑦列表操作练习</strong></h1><blockquote><p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p></blockquote><p><strong>请写程序完成下列题目：</strong></p><blockquote><p>请写程序完成下列操作<br>1.在列表的未尾增加元素15<br>2.在列表的中间位置插入元素20</p><p>3.将列表[2，5，6]合并到Ist中<br>4.移除列表中索引为3的元素<br>5.翻转列表里的所有元素<br>6.对列表里的元素进行排序，从小到大一次，从大到小一次</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. lst.append(15)</p><p>\2. lst.insert(len(lst)//2, 20)</p><p>\3. lst.extend([2, 5, 6])</p><p>\4. lst.remove(lst[3])</p><p>\5. lst = lst[::-1]</p><p>\6. lst.sort() lst.sort(reverse=True)</p></blockquote><p><strong>第二题解析：</strong></p><blockquote><p><code>len(lst)//2</code> 表示列表 <code>lst</code> 的长度除以2，即中间位置的索引。然后，<code>lst.insert()</code> 方法用于在指定的索引位置插入一个元素，这里的索引位置是中间位置，元素是 20。这样，执行完这段代码后，列表 <code>lst</code> 中就会在中间位置插入一个元素 20。</p></blockquote><p><strong>第五题解析：</strong></p><blockquote><p><code>lst[::-1]</code> 是 Python 中的切片操作，用于创建一个与原列表 <code>lst</code> 具有相同元素但顺序相反的新列表。具体来说：</p><ul><li><code>[::-1]</code>：这部分表示切片操作，其中的 <code>::</code> 表示从列表的起始位置到结束位置，而 <code>-1</code> 表示步长为 -1，即逆序遍历列表。</li></ul><p>通过将列表 <code>lst</code> 进行切片操作 <code>[::-1]</code>，代码将创建一个新的列表，其中的元素顺序与原列表 <code>lst</code> 相反。</p><p>例如，如果原列表 <code>lst</code> 是 <code>[1, 2, 3, 4, 5]</code>，那么 <code>lst[::-1]</code> 将返回一个新的列表 <code>[5, 4, 3, 2, 1]</code>，即原列表的逆序。</p><p>所以，<code>lst = lst[::-1]</code> 这段代码的作用是将列表 <code>lst</code> 中的元素顺序反转，并将结果保存回原列表 <code>lst</code> 中。</p></blockquote><p><strong>第六题解析：</strong></p><blockquote><p><code>lst.sort()</code> 是一个用于列表排序的方法。它会按照默认的升序方式对列表进行排序。例如，如果列表 <code>lst</code> 是 <code>[3, 1, 2]</code>，那么调用 <code>lst.sort()</code> 之后，列表 <code>lst</code> 将变为 <code>[1, 2, 3]</code>。</p><p><code>lst.sort(reverse=True)</code> 是对列表进行降序排序的方法。它会按照降序的方式对列表进行排序。例如，如果列表 <code>lst</code> 是 <code>[3, 1, 2]</code>，那么调用 <code>lst.sort(reverse=True)</code> 之后，列表 <code>lst</code> 将变为 <code>[3, 2, 1]</code>。</p><p>需要注意的是，这两个方法会直接修改原始列表，而不会返回一个新的排序后的列表。如果你想要获得一个新的排序后的列表，可以使用 <code>sorted()</code> 函数。例如，<code>sorted_lst = sorted(lst)</code> 会返回一个新的已排序列表，而不会修改原始列表 <code>lst</code>。</p></blockquote><h1 id="⑧复杂列表练习"><a href="#⑧复杂列表练习" class="headerlink" title="⑧复杂列表练习"></a><strong>⑧复杂列表练习</strong></h1><blockquote><p>lst = [1, 4, 5, [1, 3, 5, 6, [8, 9, 10, 12]]]</p></blockquote><p><strong>不写代码，仅凭思考来回答</strong></p><blockquote><p>1.列表Ist的长度是多少<br>2.列表Ist中有几个元素<br>3.lst[1] 的数据类型是什么<br>4.lst[3]的数据类型是什么<br>5.lst[3][4] 的值是什么<br>6.如果才能访问到 9 这个值<br>7.执行lst[3][4].append([5,6])后，列表lst的内容是什么，手写出来<br>8.lst[-1][-1][-2]的值是什么<br>9.lst[-2]的值是什么<br>10.len(lst[-1]) 的值是什么<br>11.len(lst[-1][-1])的值是什么<br>12.lst[-1][1:3] 的值是什么<br>13.lst[-1][-1][1:-2]的值是什么</p></blockquote><p><strong>解答：</strong></p><p>第1题和第2题其实是一个意思，原本统计列表里数据个数不是什么难事，可一旦出现了嵌套列表的情况，有人就分不清了，列表里的数据是以逗号分隔的，lst[3] 是一个列表，其余都是int类型数据，因此lst的长度是4<br>第3题，lst[1] = 4,是int类型数据<br>第4题，lst[3] 的数据类型是列表<br>第5题，lst[3]的值是[1,3,5,6,[8,9,10,12]]，仍然是一个列表，其索引为4的数据是[8,9,10,12]，是列表<br>第6题，lst[3][4][1]第7题，[1,4,5,[1,3,5,6,[8,9,10,12,[5,6]]]],参考5，6两个题目的解答第8题，Ist[-1]的值是[1,3,5,6,[8,9,10,12]]， 再次取索引为-1的数据为[8,9,10,12]，取索引为-2的数据为10<br>第9题，5<br>第10题，5<br>第11题，4<br>第12题，[3,5]， lst[-1]的值是[1,3,5,6,[8,9,10,12]]第13题，[9]， lst[-1][-1]的值是[8,9,10,12]，切片起始位置索引是1，值为9，结束位置是-2，值为10，由于左闭右开，最终结果是[9]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⑤合并字符串&quot;&gt;&lt;a href=&quot;#⑤合并字符串&quot; class=&quot;headerlink&quot; title=&quot;⑤合并字符串&quot;&gt;&lt;/a&gt;⑤合并字符串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;str1=“1，2，3”&lt;/p&gt;
&lt;p&gt;str2=“4，5，6”&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day04</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day04/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day04/</id>
    <published>2023-09-17T12:00:02.000Z</published>
    <updated>2023-10-17T09:08:16.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3列表与元组练习题"><a href="#1-3列表与元组练习题" class="headerlink" title="1.3列表与元组练习题"></a>1.3列表与元组练习题</h1><h1 id="①列表基础考察"><a href="#①列表基础考察" class="headerlink" title="①列表基础考察"></a>①列表基础考察</h1><p>已知一个列表<strong>lst = [1,2,3,4,5]</strong><br>1.求列表的长度<br>2.判断6 是否在列表中<br>3.lst + [6,7,8] 的结果是什么?<br>4.lst*2 的结果是什么<br>5.列表里元素的最大值是多少<br>6.列表里元素的最小值是多少<br>7.列表里所有元素的和是多少<br>8.在索引1的后面新增一个的元素109.在列表的未尾新增一个元素20</p><p><strong>解答：</strong></p><blockquote><p>\1. len(lst)</p><p>\2. 6 in lst</p><p>\3. [1,2,3,4,5,6,7,8]</p><p>\4. [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]</p><p>\5. max(lst)</p><p>\6. min(lst)</p><p>\7. sum(lst)</p><p>\8. lst.insert(1, 10)</p><p>\9. lst.append(20)</p></blockquote><h1 id="②修改列表"><a href="#②修改列表" class="headerlink" title="②修改列表"></a>②修改列表</h1><p><strong>lst = [1, [4, 6],True]</strong></p><p><strong>请将列表里所有数字修改成原来的两倍</strong></p><p>答案：</p><blockquote><p>lst[0] = 2</p><p>lst[1][0] = 4</p><p>lst[1][1] = 12</p></blockquote><p><strong>你以为存在一个函数，其功能便是将列表里所有的数据都变成原来的两倍，这样才显得变成语言是一个非常神奇的东西，但是很遗憾的告诉你，那些神奇的东西都是程序员自己实现的。</strong></p><p><strong>想要修改列表里的数据，必须通过索引对其重新赋值，上面的方法很low，你也可以写一个区数来实现这个功能，我们假设要处理的列表里只int,float,bool,和list数据，不管嵌套基层list.这个函数都应该能正确处理，下面是一段示例代码</strong></p><blockquote><p>def double_list(lst):</p><p>​    for index,item in enumerate(lst):<br>​        if isinstance(item,bool):</p><p>​            continue</p><p>​        if isinstance(item,(int,float)):</p><p>​            lst[index]*=2</p><p>​        if isinstance(item,list):</p><p>​            double_list(item)</p><p>if <em>name</em> == ‘<em>main</em>‘:</p><p>​    lst = [1,[4,6],True]</p><p>​    double_list(lst)</p><p>​    print(lst)</p></blockquote><h1 id="③元组概念考察"><a href="#③元组概念考察" class="headerlink" title="③元组概念考察"></a>③元组概念考察</h1><p><strong>写出下面代码的执行结果和最终结果的类型</strong></p><p>\1. (1,2)*2</p><p>\2. (1,)*2</p><p>\3. (1)*2</p><p><strong>解答：</strong></p><blockquote><p>\1. (1, 2, 1, 2)</p><p>\2. (1, 1)</p><p>\3. 2</p></blockquote><p>注意第2和第3个，当元组里只有一个数据时，必须有逗号，否则就变成了第三题的形式：<strong>1*2</strong></p><p><strong>当元组中只有一个数据时，如果不省略了逗号，那么小括号的作用就不再是表示元组，而是表示运算优先级</strong></p><h1 id="④合并列表"><a href="#④合并列表" class="headerlink" title="④合并列表"></a><strong>④合并列表</strong></h1><p>lst = [1,2,3]</p><p>lst2 = [4,5,6]</p><p><strong>不使用＋号运算符，将lst2合并到lst的末尾，并思考，这个过程中，是否产生了新的列表</strong></p><p><strong>解答：</strong></p><blockquote><p>lst.extend(lst2)</p></blockquote><p><strong>这个过程中不会产生新的列表，最直观的检验方式就是print(id(lst)),合并前后，lst的内存地址都没有发生变化，只是列表里的内容发生了变化</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3列表与元组练习题&quot;&gt;&lt;a href=&quot;#1-3列表与元组练习题&quot; class=&quot;headerlink&quot; title=&quot;1.3列表与元组练习题&quot;&gt;&lt;/a&gt;1.3列表与元组练习题&lt;/h1&gt;&lt;h1 id=&quot;①列表基础考察&quot;&gt;&lt;a href=&quot;#①列表基础考察&quot; c</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day03</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day03/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day03/</id>
    <published>2023-09-16T11:59:35.000Z</published>
    <updated>2023-10-17T09:08:16.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-2字符串练习题"><a href="#1-2字符串练习题" class="headerlink" title="1.2字符串练习题"></a>1.2字符串练习题</h1><h1 id="①字符串内置方法练习"><a href="#①字符串内置方法练习" class="headerlink" title="①字符串内置方法练习"></a>①字符串内置方法练习</h1><blockquote><p><strong>在交互式解释器中完成下列题目</strong><br>1.将字符串“abcd”转成大写<br>2.计算字符串“cd”在 字符串“abcd”中出现的位置<br>3.字符串“a,b,c,d”，请用逗号分割字符串，分割后的结果是什么类型的？</p><p>4.”[name]喜欢{fruit}”.format(name=”李雷”)执行会出错，请修改代码让其正确执行</p><p>\5. string =”Python is good”, 请将字符串里的Python替换成 python,并输出替换后的结果<br>6.有一个字符串 string =“python修炼第一期.html”，请写程序从这个字符串里获得.htm前面的部分，要用尽可能多的方式来做这个事情<br>7.如何获取字符串的长度?<br>8.”this is a book”,请将字符串里的book替换成apple<br>9.”this is a book”,请用程序判断该字符串是否以this开头</p><p>10.”this is a book”，请用程序判断该字符串是否以apple结尾</p><p>11.”This IS a book”请将字符串里的大写字符转成小写字符<br>12.”This IS a book”,请将字符串里的小写字符转成大写字符<br>13.”this is a book\n”,字符串的末尾有一个回车符，请将其删除</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. “abcd”.upper()<br>\2. “abcd”.find(‘cd’)<br>\3. “a,b,c,d”.split(‘,’)<br>\4. “{name}喜欢{fruit}”.format(name=”李雷”, fruit=’苹果’)<br>\5. string.replace(‘Python’, ‘python’)<br>\6. string[0:string.find(‘.html’)] 或者string[0:-5]<br>\7. 使⽤用len函数<br>\8. “this is a book”.replace(‘book’, ‘apple’)<br>\9. “this is a book”.startswith(‘this’)<br>\10. “this is a book”.endswith(‘apple’)<br>\11. “This IS a book”.lower()<br>\12. “This IS a book”.upper()<br>\13. “this is a book\n”.strip()</p></blockquote><p><strong>这里只对其中2个题目讲解</strong></p><p>第4小题的程序直接运行会报错，因为字符串里面有两个需要替换的位置，而format方法里只传入了一个参数，显然是不够</p><p>第13小题，strip()方法用于移除字符串头尾指定的字符(默认为空格或换行符)或字符序列，n 就是换行符，这里又涉及到转义字符这个概念，本篇不做详细讲解，求知欲强的同学可以自己百度一下</p><h1 id="②逻辑推理练习（字符串）"><a href="#②逻辑推理练习（字符串）" class="headerlink" title="②逻辑推理练习（字符串）"></a>②逻辑推理练习（字符串）</h1><blockquote><p><strong>不用代码，口述回答下面代码的执行结果</strong></p><p>string = “Python is good”<br>\1. string[1:20]</p><p>\2. string[20]</p><p>3.string[3:-4]<br>4.string[-10:-3]<br>5.string.lower()<br>6.string.replace(“o”，”0”)</p><p>\7. string.startswith(python’)<br>\8. string.split()<br>\9. len(string)<br>\10. string[30]<br>11.string.replace(“”,”)</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. ‘ython is good’<br>\2. 报错<br>\3. ‘hon is ‘<br>\4. ‘on is g’<br>\5. ‘python is good’<br>\6. ‘Pyth0n is g00d’<br>\7. False<br>\8. [‘Python’, ‘is’, ‘good’]<br>\9. 14<br>\10. 报错<br>\11. ‘Pythonisgood’</p></blockquote><p><strong>第2题和第10题</strong>都报错，是因为超出了索引范围，字符串长度为14，你去20和30的位置取值，当然会报错<br>关于<strong>切片操作</strong>，只需要知道从哪里开始到哪里结束就一定能推导出答案，以string[3:-4]为例，3是开始的位置，-4是结束的位置，但这个范围是左闭右开的，从3开始没错，但不会到-4，而是到-5，更前面的一个位置，python支持负数索引，或者说是反向索引，从右向左从-1开始逐渐减小。<br>第一题中，做切片的时候是从1开始，到20结束，即便是右开，直到19，也仍然超出了索引范围，为什么不报错呢，这就是语言设计者自己的想法了，切片时，不论是开始位置还是结束位置，超出索引范围都不会报错，我猜，大概是由于切片是一个范围操作，这个范围内有值就切出来，没值返回空字符串就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-2字符串练习题&quot;&gt;&lt;a href=&quot;#1-2字符串练习题&quot; class=&quot;headerlink&quot; title=&quot;1.2字符串练习题&quot;&gt;&lt;/a&gt;1.2字符串练习题&lt;/h1&gt;&lt;h1 id=&quot;①字符串内置方法练习&quot;&gt;&lt;a href=&quot;#①字符串内置方法练习&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
</feed>
