<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>大数据科技协会-zky</title>
  
  
  <link href="https://bdta-zky.github.io/atom.xml" rel="self"/>
  
  <link href="https://bdta-zky.github.io/"/>
  <updated>2023-12-24T14:09:29.126Z</updated>
  <id>https://bdta-zky.github.io/</id>
  
  <author>
    <name>刘浩龙</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python150题day20</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day20/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day20/</id>
    <published>2023-12-24T13:59:35.000Z</published>
    <updated>2023-12-24T14:09:29.126Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-7-startswith"><a href="#4-7-startswith" class="headerlink" title="4.7 startswith"></a><strong>4.7 startswith</strong></h2><p>“startswith”是Python字符串方法之一，用于检查字符串是否以特定的前缀开始。这个方法通常用于条件检查，以确定一个字符串是否以另一个字符串作为前缀。</p><p>这是startswith方法的语法：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.startswith(prefix[, start[, end]]) </span><br></pre></td></tr></table></figure></blockquote><ul><li><code>str</code> 是要检查的字符串。</li><li><code>prefix</code> 是要检查的前缀字符串。</li><li><code>start</code> （可选）是可选的开始搜索的起始位置。</li><li><code>end</code> （可选）是可选的结束搜索的结束位置。</li></ul><p>startswith方法返回一个布尔值，如果字符串以指定的前缀开始，则返回True，否则返回False。</p><p><strong>要求：</strong></p><p>实现函数is startswith，如果字符串source是以substr开头的，则函数返回True,反之返回<br> False</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_startswith</span>(<span class="params">source,substr</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断字符串source是否以substr开头</span></span><br><span class="line"><span class="string">:paramsource:</span></span><br><span class="line"><span class="string">:paramsubstr:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>source<span class="keyword">or</span> <span class="keyword">not</span>substr:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(substr) &gt; <span class="built_in">len</span>(source):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">for</span>index,item<span class="keyword">in</span> <span class="built_in">enumerate</span>(substr):</span><br><span class="line"><span class="keyword">if</span>item!=source[index]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span><span class="comment">#如果for循环不是因为break结束的，就会进⼊到else语句块</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>思路：</strong></p><p>函数首先要判断传入的参数是否合法，这里默认传入的都是字符串，那么我们要需要判断字符串是否有空串的情况<br> 如果substr的长度大于source的长度，直接返回False<br> 从索引0开始，遍历substr,从source上获得相同索引的字符，两者进行比较，只要有一个字符不相同，则可以立即返回False</p><h2 id="4-8-endswith"><a href="#4-8-endswith" class="headerlink" title="4.8 endswith"></a>4.8 endswith</h2><p><code>&quot;endswith&quot;</code>是Python字符串方法之一，用于检查字符串是否以特定的后缀结尾。这个方法通常用于条件检查，以确定一个字符串是否以另一个字符串作为后缀。</p><p>这是<code>endswith</code>方法的语法：</p><blockquote><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">str.endswith(suffix[, start[, end]]) </span><br></pre></td></tr></table></figure></blockquote><ul><li><code>str</code> 是要检查的字符串。</li><li><code>suffix</code> 是要检查的后缀字符串。</li><li><code>start</code> （可选）是可选的开始搜索的起始位置。</li><li><code>end</code> （可选）是可选的结束搜索的结束位置。</li></ul><p><code>endswith</code>方法返回一个布尔值，如果字符串以指定的后缀结尾，则返回True，否则返回False。</p><p><strong>要求：</strong></p><p>实现函数is endswith，判断字符串source是否以substr结尾</p><p><strong>代码：</strong></p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">is_endswith</span>(<span class="params">source,substr</span>):</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">判断字符串source是否以substr结尾</span></span><br><span class="line"><span class="string">:paramsource:</span></span><br><span class="line"><span class="string">:paramsubstr:</span></span><br><span class="line"><span class="string">:return:</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span>source<span class="keyword">or</span> <span class="keyword">not</span>substr:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">len</span>(substr) &gt; <span class="built_in">len</span>(source):</span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">start_index= <span class="built_in">len</span>(source) - <span class="built_in">len</span>(substr)</span><br><span class="line"><span class="keyword">for</span>index<span class="keyword">in</span> <span class="built_in">range</span>(start_index, <span class="built_in">len</span>(source)):</span><br><span class="line"><span class="keyword">if</span>source[index] !=substr[index-start_index]:</span><br><span class="line"><span class="keyword">break</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"><span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p><strong>思路：</strong></p><p>这个练习题的解法其实和is startswith函数相差无几，所不同的是，在is startswith函数中要从索引0开始进行相同位置字符的比较，而现在，是要判断是否以substr结尾，所以我们从索引len(source) - len(substr)开始逐一进行比较</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-7-startswith&quot;&gt;&lt;a href=&quot;#4-7-startswith&quot; class=&quot;headerlink&quot; title=&quot;4.7 startswith&quot;&gt;&lt;/a&gt;&lt;strong&gt;4.7 startswith&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;“star</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day19</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day19/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day19/</id>
    <published>2023-12-24T13:59:27.000Z</published>
    <updated>2023-12-24T14:08:47.785Z</updated>
    
    <content type="html"><![CDATA[<h2 id="4-4-字符串大写转小写"><a href="#4-4-字符串大写转小写" class="headerlink" title="4.4 字符串大写转小写"></a>4.4 字符串大写转小写</h2><p>在Python中，可以使用<code>lower()</code>方法将字符串中的大写字母转换为小写字母。<code>lower()</code>方法返回一个新的字符串，原始字符串本身不会被修改。</p><p>下面是一个示例：</p><blockquote><p>text = “HELLO, WORLD!”<br>lower_text = text.lower()<br>print(lower_text)  # 输出：hello, world!</p></blockquote><p>在上面的示例中，我们将字符串<code>text</code>中的大写字母转换为小写字母，并将转换后的新字符串赋值给<code>lower_text</code>变量。</p><p>需要注意的是，<code>lower()</code>方法只能将大写字母转换为小写字母，对于已经是小写字母或其他字符的部分，不会有任何影响。</p><p>另外，如果想将字符串中的小写字母转换为大写字母，可以使用**<code>upper()</code>**方法。</p><h2 id="4-5-判断字符串是否全部为小写字母"><a href="#4-5-判断字符串是否全部为小写字母" class="headerlink" title="4.5 判断字符串是否全部为小写字母"></a>4.5 判断字符串是否全部为小写字母</h2><p>在Python中，可以使用<code>islower()</code>方法判断字符串中的所有字母是否都是小写字母。如果字符串中至少有一个非小写字母，<code>islower()</code>方法返回<code>False</code>，否则返回<code>True</code>。</p><p>下面是一个示例：</p><blockquote><p>text1 = “hello, world!”<br>text2 = “Hello, World!”<br>print(text1.islower())  # 输出：True<br>print(text2.islower())  # 输出：False</p></blockquote><p>在上面的示例中，我们分别使用<code>islower()</code>方法判断字符串<code>text1</code>和<code>text2</code>中的所有字母是否都是小写字母。由于<code>text1</code>中的所有字母都是小写字母，因此<code>islower()</code>方法返回<code>True</code>；而<code>text2</code>中包含大写字母，因此<code>islower()</code>方法返回<code>False</code>。</p><p>需要注意的是，<code>islower()</code>方法只能用于判断字符串中的字母是否都是小写字母，对于其他字符，比如数字、标点符号等，不会有任何影响。</p><p>另外，如果想判断字符串中的所有字母是否都是大写字母，可以使用<code>**isupper()**</code>方法。</p><h2 id="4-6-isdigit判断是否只包含数字"><a href="#4-6-isdigit判断是否只包含数字" class="headerlink" title="4.6 isdigit判断是否只包含数字"></a>4.6 isdigit判断是否只包含数字</h2><p>在Python中，可以使用<code>isdigit()</code>方法判断一个字符串是否只包含数字字符。如果字符串中只包含数字字符，<code>isdigit()</code>方法返回<code>True</code>，否则返回<code>False</code>。</p><p>下面是一个示例：</p><blockquote><p>text1 = “12345”<br>text2 = “12.345”<br>print(text1.isdigit())  # 输出：True<br>print(text2.isdigit())  # 输出：False</p></blockquote><p>在上面的示例中，我们分别使用<code>isdigit()</code>方法判断字符串<code>text1</code>和<code>text2</code>是否只包含数字字符。由于<code>text1</code>中只包含数字字符，因此<code>isdigit()</code>方法返回<code>True</code>；而<code>text2</code>中包含小数点，因此<code>isdigit()</code>方法返回<code>False</code>。</p><p>需要注意的是，<code>isdigit()</code>方法只能用于判断字符串中是否只包含数字字符，对于其他字符，比如字母、标点符号等，不会有任何影响。</p><p>另外，如果想判断一个字符串是否只包含字母字符，可以使用<code>isalpha()</code>方法；如果想判断一个字符串是否只包含数字和字母字符，可以使用<code>isalnum()</code>方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;4-4-字符串大写转小写&quot;&gt;&lt;a href=&quot;#4-4-字符串大写转小写&quot; class=&quot;headerlink&quot; title=&quot;4.4 字符串大写转小写&quot;&gt;&lt;/a&gt;4.4 字符串大写转小写&lt;/h2&gt;&lt;p&gt;在Python中，可以使用&lt;code&gt;lower()&lt;/co</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day18</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day18/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day18/</id>
    <published>2023-12-24T13:59:21.000Z</published>
    <updated>2023-12-24T14:08:37.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="4-字符串方法"><a href="#4-字符串方法" class="headerlink" title="4.字符串方法"></a>4.字符串方法</h1><h2 id="4-1-find"><a href="#4-1-find" class="headerlink" title="4.1 find"></a>4.1 find</h2><p>在Python中，<code>find()</code>方法用于在字符串中查找子字符串，并返回子字符串第一次出现的索引位置。如果找不到子字符串，<code>find()</code>方法返回-1。</p><blockquote><p>str.find(sub, start, end)</p></blockquote><p>其中，<code>str</code>是要搜索的字符串，<code>sub</code>是要查找的子字符串。<code>start</code>和<code>end</code>是可选参数，用于指定搜索的起始和结束位置。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>index = sentence.find(“world”)<br>print(index)  # 输出：7</p></blockquote><p>在上面的示例中，我们在字符串<code>sentence</code>中查找子字符串”world”，并将其第一次出现的索引位置打印出来。</p><p>需要注意的是，<code>find()</code>方法区分大小写。如果要进行不区分大小写的搜索，可以使用<code>lower()</code>或<code>upper()</code>方法将字符串转换为统一的大小写，然后再进行搜索。</p><p>此外，还有其他类似的方法可用于在字符串中查找子字符串，如<code>index()</code>方法和<code>rfind()</code>方法。<code>index()</code>方法与<code>find()</code>方法类似，但如果找不到子字符串，会引发<code>ValueError</code>异常。<code>rfind()</code>方法与<code>find()</code>方法类似，但从字符串的末尾开始搜索子字符串。</p><h2 id="4-2-replace"><a href="#4-2-replace" class="headerlink" title="4.2 replace"></a>4.2 replace</h2><p>在Python中，<code>replace()</code>方法用于替换字符串中的子字符串。</p><p><code>replace()</code>方法的语法如下：</p><blockquote><p>str.replace(old, new, count)</p></blockquote><p>其中，<code>str</code>是要进行替换操作的字符串，<code>old</code>是要被替换的子字符串，<code>new</code>是替换后的新字符串。<code>count</code>是可选参数，用于指定替换的次数。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>new_sentence = sentence.replace(“world”, “Python”)<br>print(new_sentence)  # 输出：Hello, Python!</p></blockquote><p>在上面的示例中，我们将字符串<code>sentence</code>中的子字符串”world”替换为”Python”，并将替换后的新字符串赋值给<code>new_sentence</code>变量。</p><p>需要注意的是，<code>replace()</code>方法返回一个新的字符串，原始字符串本身不会被修改。如果要对原始字符串进行修改，可以将结果重新赋值给原始字符串变量。</p><p>另外，如果不指定<code>count</code>参数，<code>replace()</code>方法会替换所有匹配的子字符串。如果指定了<code>count</code>参数，只会替换前<code>count</code>个匹配的子字符串。</p><h2 id="4-3-split"><a href="#4-3-split" class="headerlink" title="4.3 split"></a>4.3 split</h2><p>在Python中，<code>split()</code>方法用于将字符串分割成多个子字符串，返回一个包含分割后子字符串的列表。</p><p><code>split()</code>方法的语法如下：</p><blockquote><p>str.split(sep, maxsplit)</p></blockquote><p>其中，<code>str</code>是要进行分割操作的字符串，<code>sep</code>是分隔符，默认情况下是空格。<code>maxsplit</code>是可选参数，用于指定最多分割的次数。</p><p>下面是一个示例：</p><blockquote><p>sentence = “Hello, world!”<br>words = sentence.split()<br>print(words)  # 输出：[‘Hello,’, ‘world!’]</p></blockquote><p>在上面的示例中，我们将字符串<code>sentence</code>分割成多个子字符串，以空格为分隔符。由于<code>sentence</code>中只包含两个单词，因此<code>split()</code>方法返回一个包含两个元素的列表。</p><p>需要注意的是，如果不指定分隔符，<code>split()</code>方法会以空格为分隔符。如果指定了分隔符，<code>split()</code>方法会使用指定的分隔符进行分割。</p><p>另外，如果指定了<code>maxsplit</code>参数，<code>split()</code>方法会最多分割<code>maxsplit</code>次。如果不指定<code>maxsplit</code>参数，则会分割所有符合条件的子字符串。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;4-字符串方法&quot;&gt;&lt;a href=&quot;#4-字符串方法&quot; class=&quot;headerlink&quot; title=&quot;4.字符串方法&quot;&gt;&lt;/a&gt;4.字符串方法&lt;/h1&gt;&lt;h2 id=&quot;4-1-find&quot;&gt;&lt;a href=&quot;#4-1-find&quot; class=&quot;headerli</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day17</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day17/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day17/</id>
    <published>2023-12-24T13:59:16.000Z</published>
    <updated>2023-12-24T14:08:24.329Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-9-enumerate"><a href="#3-9-enumerate" class="headerlink" title="3.9 enumerate"></a>3.9 enumerate</h1><p>enumerate()函数用于将一个可遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在for循环当中，下面是使用示例：</p><blockquote><p>lst = [‘a’, ‘b’, ‘c’]</p><p>for index, item in enumerate(lst):</p><p>​    print(index, item)</p></blockquote><p>程序输出：</p><blockquote><p>0 a</p><p>1 b</p><p>2 c</p></blockquote><p><strong>仿造该功能实现下面的函数:</strong></p><blockquote><p>def my_enumerate(lst):</p><p>​    “””</p><p>​    实现和enumerate 类似的功能</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_enumerate(lst):</p><p>​    for i in range(len(lst)):</p><p>​        yield i,lst[i]</p><p>lst = [‘a’,’b’,’c’]</p><p>for index,item in my_enumerage(lst):</p><p>​    print(index,item)</p></blockquote><p><strong>思路：</strong></p><p>这个函数需要对<strong>生成器</strong>有一定的理解和认识。一个函数里出现了<strong>yield关键字</strong>，那么这个函数就是生成器函数，该函数返回的是一个生成器。</p><p>yield和return有着相似的功能，都会将数据返回给调用者，<strong>不同之处在于，return执行后，函数结束了，而yield执行后，会保留当前的状态，等到下一次执行时，恢复之前的状态，继续执行。</strong></p><p>在函数内部，使用for循环通过索引</p><p>遍历lst，使yield返回索引和 索引位置上的元素</p><p><strong>tips：</strong></p><blockquote><p><strong><code>yield</code></strong> 是一个关键字，用于<strong>定义生成器函数</strong>。生成器函数是一种特殊类型的函数，它可以暂停执行并在需要时产生一个值（或一系列值），然后再继续执行。</p><p>当在生成器函数中使用 <code>yield</code> 语句时，它会将一个值返回给调用者，并且当前的函数状态会被保存下来。下次调用生成器函数时，函数会从上次暂停的位置继续执行，而不是从头开始执行。这使得生成器函数能够逐步生成值，而不需要一次性计算和返回所有的值。以下是一个简单的示例，展示了生成器函数的使用：</p><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">number_generator</span>():</span><br><span class="line">    <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个生成器对象</span></span><br><span class="line">generator = number_generator()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过调用 next() 函数获取生成器的下一个值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 1</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 2</span></span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">next</span>(generator))  <span class="comment"># 输出: 3</span></span><br></pre></td></tr></table></figure><p><img src="data:image/gif;base64,R0lGODlhAQABAPABAP///wAAACH5BAEKAAAALAAAAAABAAEAAAICRAEAOw==" alt="点击并拖拽以移动"></p><p>在上面的示例中，<code>number_generator()</code> 是一个生成器函数，它通过 <code>yield</code> 语句逐步生成数字 1、2 和 3。每次调用 <code>next()</code> 函数时，生成器函数会从上次暂停的位置继续执行，并返回下一个生成的值。</p><p>生成器函数非常有用，特别是在处理大量数据或需要逐步生成结果的情况下。通过使用生成器函数，可以减少内存消耗，并且可以在需要时按需生成值，而不必一次性生成所有的值。</p></blockquote><h1 id="3-10-all"><a href="#3-10-all" class="headerlink" title="3.10 all"></a>3.10 all</h1><p>all()函数用于判断给定的可迭代参数iterable中的所有元素是否都为True，示例代码如下：</p><blockquote><p>lst = [True, False, True]</p><p>print(all(lst))</p></blockquote><p>返回结果为False，实现一个函数，完成类似的功能</p><p><strong>代码：</strong></p><blockquote><p>def my_all(seq):</p><p>​    for item in seq:</p><p>​        if not item:</p><p>​            return False</p><p>​    return True</p></blockquote><p><strong>思路：</strong></p><p>直接用for循环遍历，如果遍历到的元素有False则直接返回False，如果没有是False的，遍历结束返回True</p><h1 id="3-11-any"><a href="#3-11-any" class="headerlink" title="3.11 any"></a>3.11 any</h1><p>any函数用于判断给定的可迭代参数 iterable 中的所有元素是否至少有一个为True</p><blockquote><p>lst = [True, False, False]</p><p>print(any(lst)</p></blockquote><p>返回结果为True，实现一个函数，完成类似功能</p><p><strong>代码：</strong></p><blockquote><p>def my_all(seq):</p><p>​    for item in seq:</p><p>​        if item:</p><p>​            return True</p><p>​    return False</p></blockquote><p><strong>思路：</strong></p><p>类似all，遍历列表，如果有一个是True，则直接返回True，否则则是全不是True，循环结束返回False</p><h1 id="3-12-bin"><a href="#3-12-bin" class="headerlink" title="3.12 bin"></a>3.12 bin</h1><p>函数bin可以获得整数的二进制形式：</p><blockquote><p>print(bin(10))</p></blockquote><p>输出结果为 0b1010</p><p>实现一个函数，完成相同功能，为了降低难度，只需要考虑正整数且不需要在开头加0b</p><p><strong>代码：</strong></p><blockquote><p>def my_bin(value):</p><p>​    lst = []</p><p>​    while value:</p><p>​        if value % 2 == 1:</p><p>​            lst.append(‘1’)</p><p>​        else:</p><p>​            lst.append(‘0’)</p><p>​    value = value // 2  # 也可写成value = value &gt;&gt; 1</p><p>​    </p><p>​    lst = lst[::-1]</p><p>​    return ‘’.join(lst)</p></blockquote><p><strong>思路：</strong></p><ol><li>创建一个空列表 <code>lst</code> 用于存储二进制表示的位。</li><li>进入一个循环，直到 <code>value</code> 的值为 0。</li><li>在循环中，检查 <code>value</code> 是否为奇数（通过取模运算 <code>value % 2 == 1</code>）。如果是奇数，将字符 <code>&#39;1&#39;</code> 添加到列表 <code>lst</code> 中，表示当前位为 1；否则，将字符 <code>&#39;0&#39;</code> 添加到列表 <code>lst</code> 中，表示当前位为 0。</li><li>将 <code>value</code> 的值除以 2（通过整除运算 <code>value // 2</code>），以便在下一次循环中处理下一个位。</li><li>循环结束后，反转列表 <code>lst</code> 的顺序，以得到正确的二进制表示。</li><li>使用 <code>&#39;&#39;.join(lst)</code> 将列表中的字符连接成一个字符串，表示整数的二进制形式。</li><li>返回二进制字符串。</li></ol><p><strong>tips：</strong></p><blockquote><p><strong><code>value = value &gt;&gt; 1</code></strong> 是一个位运算操作，用于将变量 <code>value</code> 的值向右移动一位。</p><p>具体而言，<code>&gt;&gt;</code> 是右移位运算符，它将二进制数向右移动指定的位数。在这种情况下，<code>value</code> 的值被向右移动一位，相当于将其二进制表示的所有位向右移动一位，并将最右边的位丢弃。</p><p>例如，如果 <code>value</code> 的初始值为 10，其二进制表示为 <code>1010</code>。执行 <code>value = value &gt;&gt; 1</code> 后，<code>value</code> 的值将变为 5，其二进制表示为 <code>0101</code>。</p><p>这种右移位操作可以理解为将一个数除以 2（向下取整），因为向右移动一位等于将所有位向右移动一位，并在最左边添加一个零。在二进制中，向右移动一位相当于将数值除以 2。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-9-enumerate&quot;&gt;&lt;a href=&quot;#3-9-enumerate&quot; class=&quot;headerlink&quot; title=&quot;3.9 enumerate&quot;&gt;&lt;/a&gt;3.9 enumerate&lt;/h1&gt;&lt;p&gt;enumerate()函数用于将一个可遍历的数据对象</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day16</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day16/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day16/</id>
    <published>2023-12-24T13:59:07.000Z</published>
    <updated>2023-12-24T14:07:43.826Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-5-int"><a href="#3-5-int" class="headerlink" title="3.5 int"></a>3.5 int</h1><p>内置函数int，可以将float、全是数字的字符串转换成int类型的数据，为了降低难度，这个练习题只要求你实现其中的一种功能，将全是数字组成的字符串转换成int类型数据，例如将字符此案“123”转换成整数123，函数定义如下：</p><blockquote><p>def my_int(string):</p><p>​    “””</p><p>​    将字符串string转成int类型数据</p><p>​    不考虑string的类型,默认就是符合要求的字符串</p><p>​    传⼊字符串”432”</p><p>​    返回整数432</p><p>​    :param string:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9 }</p><p>def my_int(string):</p><p>​    res = 0</p><p>​    for item in string:</p><p>​        int_value = str_int_dic[item]</p><p>​        res = res*10 + int_value</p><p>​    return res</p></blockquote><p><strong>思路：</strong></p><p>遍历字符串，将每个字符串里的每个字符传换成int类型的数值，这个过程可以使用字典来完成，建立一个字典，字符串的数字做key，int类型的数字做value，例如下面的字典</p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’: 8, ‘9’: 9 }</p></blockquote><p>得到数字后，还得考虑这个数字是哪一位的，是千位还是百位，这里可以使用一个<strong>技巧，遍历的过程都是从左向右进行的，设置一个变量保存转换后的int数据，初始值赋为0，每一次循环后，都用这个变量乘10再加上所遍历的数值，这样就巧妙地解决了位数问题。</strong></p><h1 id="3-6-str"><a href="#3-6-str" class="headerlink" title="3.6 str"></a><strong>3.6 str</strong></h1><p>内置函数str的功能非常强大，想要模仿实现一个相同功能的函数是非常困难的，因此本练习题只要求将int类型的数据转换成字符串，实现下面的函数：</p><blockquote><p>def my_str(int_value):</p><p>​    “””</p><p>​    将int_value转换成字符串</p><p>​    :param int_value:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_str(int_value):</p><p>  if int_value == 0:<br>    return ‘0’</p><p>  lst = []<br>  is_positive = True  #标记是否是负数<br>  if int_value &lt; 0:<br>    is_positive = False<br>    int_value = abs(int_value)</p><p>  while int_value:<br>    number = int_value % 10<br>    int_value //= 10<br>    str_number = chr(number + 48)<br>    lst.append(str_number)</p><p>  if not is_positive:<br>    lst.append(‘-‘)</p><p>  lst = lst[::-1]  #倒序输出<br>  return ‘’.join(lst)</p></blockquote><p><strong>代码详解：</strong></p><blockquote><p>  <strong>if int_value == 0:<br>    return ‘0’</strong></p><p>首先，函数检查输入的整数是否为0。如果是0，那么函数直接返回字符串<code>&#39;0&#39;</code>，表示整数0的字符串形式。</p><p>  <strong>lst = []<br>  is_positive = True<br>  if int_value &lt; 0:<br>    is_positive = False<br>    int_value = abs(int_value)</strong></p><p>接下来，函数创建一个空列表<code>lst</code>，用于存储每个数字的字符形式。同时，函数定义一个布尔变量<code>is_positive</code>，用于表示整数的正负情况。如果输入的整数<code>int_value</code>小于0，说明它是一个负数，那么将<code>is_positive</code>设置为<code>False</code>，并将<code>int_value</code>取绝对值，以便后续处理。</p><p>  <strong>while int_value:<br>    number = int_value % 10<br>    int_value //= 10<br>    str_number = chr(number + 48)<br>    lst.append(str_number)</strong></p><p>接下来是一个循环，用于将整数的每个位数提取出来并转换为字符形式。循环条件是<code>int_value</code>不为0，即还有位数需要处理。在每次循环中，通过取整数<code>int_value</code>除以10的余数，可以得到当前位的数字。然后，将<code>int_value</code>整除以10，以便处理下一位。将数字转换为字符的过程使用了<code>chr()</code>函数，其中<code>number + 48</code>将数字转换为对应的ASCII码。将字符添加到列表<code>lst</code>中。</p><p>  <strong>if not is_positive:<br>    lst.append(‘-‘)<br>  lst = lst[::-1]<br>  return ‘’.join(lst)</strong></p><p>在循环结束后，检查整数的正负情况。如果输入的整数为负数，即<code>is_positive</code>为<code>False</code>，那么在最终的字符串前添加一个负号<code>&#39;-&#39;</code>。然后，将列表<code>lst</code>进行反转操作，以便得到正确的数字顺序。最后，使用<code>&#39;&#39;.join(lst)</code>将列表中的字符连接成一个字符串，并将其作为函数的返回值。</p></blockquote><p>总体来说，这段代码的作用是将整数转换为字符串形式。它通过不断地取整数的每个位数，并将每个位数的字符形式存储在列表中，最后将列表中的字符连接起来，得到整数的字符串表示。</p><p><strong>思路：</strong></p><p>int类型的数据，不能像字符串那样使用for循环进行遍历，但<strong>可以结合/和%操作符从各位向高位进行遍历，获取到某一位的数字之后，将其转换成字符串append到一个列表中。</strong></p><p><strong>遍历结束后，翻转列表，用空字符串join这个列表，即可得到转换后的字符串。</strong></p><p>单个数字，怎样转换成字符串？可以使用3.6中类似的方法， <strong>创建一个字典，数字为key，字符串数字为value</strong></p><blockquote><p>int_str_dict = { 0: ‘0’, 1: ‘1’, 2: ‘2’, 3: ‘3’, 4: ‘4’, 5: ‘5’, 6: ‘6’, 7: ‘7’, 8: ‘8’, 9: ‘9’, }</p></blockquote><p>获得某一位数字之后，通过字典获得对应的字符串，此外，还可以通过ASCII码来获得与之对应的数字字符。以3为例，chr(3+48)即可得到字符串“3”，其原理，字符串3的ASCII码表十进制数值为51，恰好比3大48，其他数值，也同样如此。</p><p>细节性问题：</p><blockquote><p>①如果传入的参数是0，那么直接返回字符串‘0’</p><p>②如果传入的参数是负数，那么需要标识记录，最后在列表里append一个‘-’字符串</p><p>③lst=[1,2,3], 反转 lst=lst[::-1]</p></blockquote><h1 id="3-7-float"><a href="#3-7-float" class="headerlink" title="3.7 float"></a>3.7 float</h1><p>为了降低难度，只要求将字符串转换成float类型的数据，并且字符串都是符合”xx.xx”类型的字符串，例如“34.22”</p><blockquote><p>def my_float(string):</p><p>“””</p><p>将字符串string转换成float类型数据</p><p>:param string:</p><p>:return:</p><p>“””</p><p>pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>str_int_dic = { ‘0’: 0, ‘1’: 1, ‘2’: 2, ‘3’: 3, ‘4’: 4, ‘5’: 5, ‘6’: 6, ‘7’: 7, ‘8’:  8, ‘9’: 9}</p><p>def my_float(string):</p><p>​    arrs = string.split(‘.’)</p><p>​    int_value = my_int(arrs[0])    #整数部分</p><p>​    float_value = my_int(arrs[1])  #小数部分</p><p>​    while float_value &gt; 1:</p><p>​        float_value *= 0.1</p><p>​    return int_value + float_value</p></blockquote><p><strong>思路：</strong></p><p>使用<strong>split函数</strong>，可以以”.”作为分隔符，可以将字符串分割为两部分，<strong>整数部分</strong>和<strong>小数部分</strong>，以”34.22”为例，分别得到整数<strong>34</strong>和<strong>22</strong>，对于22，不停的乘以0.1，直到它的数值小于1，就得到了小数部分</p><h1 id="3-8-len"><a href="#3-8-len" class="headerlink" title="3.8 len"></a>3.8 len</h1><p>内置函数len可以获得<strong>可迭代对象</strong>的长度，例如字符串、列表、元组、集合。实现一个类似功能的函数，获得数据的长度。</p><blockquote><p>def my_len(obj):</p><p>​    “””</p><p>​    获得obj对象的⻓度</p><p>​    :param obj:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>from collections import Iterable</p><p>def my_len(obj):</p><p>​    if not isinstance(obj, Iterable):</p><p>​        return None</p><p>​    length = 0</p><p>​    for item in obj:</p><p>​        length += 1</p><p>​    return length</p></blockquote><p><strong>思路：</strong></p><p>使用for循环遍历对象，<strong>循环的次数就是这个对象的长度</strong>，只需要一个变量来保存循环的次数就可以了。</p><p>对obj参数的检查，可以使用<strong>isinstance</strong>判断是否为列表、元组、字典、集合、字符串中的某一个，更为简便的做法就是，这些对象都是<strong>可迭代对象</strong>，<strong>isinstance（obj，lterable）</strong>可以判断obj是否为可迭代对象</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-5-int&quot;&gt;&lt;a href=&quot;#3-5-int&quot; class=&quot;headerlink&quot; title=&quot;3.5 int&quot;&gt;&lt;/a&gt;3.5 int&lt;/h1&gt;&lt;p&gt;内置函数int，可以将float、全是数字的字符串转换成int类型的数据，为了降低难度，这个练习题只</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day15</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day15/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day15/</id>
    <published>2023-12-24T13:59:01.000Z</published>
    <updated>2023-12-24T14:07:21.296Z</updated>
    
    <content type="html"><![CDATA[<h1 id="3-内置函数篇"><a href="#3-内置函数篇" class="headerlink" title="3.内置函数篇"></a>3.内置函数篇</h1><h1 id="3-1-abs"><a href="#3-1-abs" class="headerlink" title="3.1 abs"></a>3.1 abs</h1><p>abs函数返回数字的绝对值，请实现下面的函数，模仿abs函数的功能，返回数字的绝对值</p><blockquote><p>def my_abs(number):</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_abs(number):</p><p>​    if not isinstance(number, (float, int)):</p><p>​         return number</p><p>​    if number &lt; 0:</p><p>​        number *= -1</p><p>​    return numbe</p></blockquote><p><strong>思路：</strong></p><blockquote><p>处于<strong>程序健壮性</strong>考虑，要对传入的number参数进行检查，判断其类型是否为数字类型，float和int是比较常用的数据类型，复数类型基本接触不到，因此不考虑。<br><strong>判断变量类型</strong>，可以使用<strong>isinstance</strong>函数，该函数的第一个参数是需要检查类型的对象，第二个参数可以是数据类型，也可以是一个元组，元组里是多个数据类型，只要满足其中一个就返True<br>如果number的数值小于0，乘以-1就得到了绝对值</p></blockquote><h1 id="3-2-sum"><a href="#3-2-sum" class="headerlink" title="3.2 sum"></a>3.2 sum</h1><p>sum函数可以获取列表所有数据的综合，模仿这个功能实现下面的函数</p><blockquote><p>def my_sum(lst):</p><p>​    “””</p><p>​    返回列表⾥所有数据的总和</p><p>​    如果列表⾥有⾮数字类型的数据，忽略不管</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_sum(lst):</p><p>sum_res = 0</p><p>if not isinstance(lst, list):</p><p>​    return sum_res</p><p>for item in lst:</p><p>​    if isinstance(item, (float, int)):</p><p>​        sum_res += item</p><p>return sum_res</p></blockquote><p><strong>思路：</strong></p><blockquote><p>①对传入的参数lst，要进行类型检查</p><p>②遍历列表，遇到数字类型的数据就进行加和操作</p></blockquote><h1 id="3-3-max"><a href="#3-3-max" class="headerlink" title="3.3 max"></a>3.3 max</h1><p>max函数返回序列中的最大值，传入的参数可以是列表，也可以是元组，实现下面的函数，实现同样的功能，如果序列里有非数字类型的数据，可以忽略，如果序列是空的，可以直接返回None</p><blockquote><p>def my_max(seq):</p><p>​    “””</p><p>​    返回序列⾥的最⼤值</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p></blockquote><p><strong>代码：</strong></p><blockquote><p>def my_max(seq):</p><p>​    max_value=None</p><p>​    if not isinstance(seq,(list,tuple)):</p><p>​        return max_value</p><p>​    if len(seq)=0:</p><p>​        return max_value</p><p>​    max_value=seq[0]</p><p>​    for item in seq:</p><p>​        if not isinstance(item,(int,float)):</p><p>​            continue</p><p>​        if item&gt;max_value:</p><p>​            item=max_value</p><p>​    return max_value</p></blockquote><p><strong>思路：</strong></p><blockquote><p>①对传入的参数seq需要进行类型检查，如果既不是列表也不是元组，那么就返回None</p><p>②如果序列是空的，也直接返回None</p><p>③ 遍历序列中的元素，如果数据的类型不属于数字类型，那么就忽略跳过</p></blockquote><h1 id="3-4-min"><a href="#3-4-min" class="headerlink" title="3.4 min"></a>3.4 min</h1><p>min函数返回序列中的最小值，传入的参数可以是列表，也可以是元组，实现下面的函数，实现同样的功能，如果序列里又非数字类型的数据，可以忽略</p><blockquote><p>def my_min(seq):</p><p>​    “””</p><p>​    返回序列⾥的最⼩值</p><p>​    :param lst:</p><p>​    :return:</p><p>​    “””</p><p>​    pass</p></blockquote><p><strong>代码（与max类似）：</strong></p><blockquote><p>def my_min(seq):</p><p>​    min_value=None</p><p>​    if not isinstance(seq,(list,tuple)):</p><p>​        return min_value</p><p>​    if len(seq)=0:</p><p>​        return min_value</p><p>​    min_value=seq[0]</p><p>​    for item in seq:</p><p>​        if not isinstance(item,(int,float)):</p><p>​            continue</p><p>​        if item&lt;min_value:</p><p>​            item=min_value</p><p>​    return min_value</p></blockquote><p><strong>思路（与max一致）：</strong></p><blockquote><p>①对传入的参数seq需要进行类型检查，如果既不是列表也不是元组，那么就返回None</p><p>②如果序列是空的，也直接返回None</p><p>③ 遍历序列中的元素，如果数据的类型不属于数字类型，那么就忽略跳过</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;3-内置函数篇&quot;&gt;&lt;a href=&quot;#3-内置函数篇&quot; class=&quot;headerlink&quot; title=&quot;3.内置函数篇&quot;&gt;&lt;/a&gt;3.内置函数篇&lt;/h1&gt;&lt;h1 id=&quot;3-1-abs&quot;&gt;&lt;a href=&quot;#3-1-abs&quot; class=&quot;headerlink</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day14</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day14/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day14/</id>
    <published>2023-12-24T13:58:55.000Z</published>
    <updated>2023-12-24T14:06:58.153Z</updated>
    
    <content type="html"><![CDATA[<h1 id="③continue的好处"><a href="#③continue的好处" class="headerlink" title="③continue的好处"></a>③continue的好处</h1><p><strong>break是跳出循环体，continue是跳过continue语句后面的代码块，循环并不停止</strong><br>题目要求:<br>使用input函数接受用户的输入，如果用户输入的数值小于等于10，则判断是奇数还是偶数如果数值大于10，则输出“输入大于10，不判断奇偶”,用户输入quit，结束程序</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数,如果想停⽌程序，输⼊quit:”)</p><p>​    if input_str == ‘quit’:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number &gt; 10:</p><p>​        print(“输入大于10，不判断奇偶”)</p><p>​        continue</p><p>​    if number % 2 == 0:</p><p>​        print(“输⼊为偶数”)</p><p>​    else:</p><p>​        print(“输⼊为奇数”)</p></blockquote><p>当number大于10 的时候，后面的那4行代码就不会被执行，直接进入到下一次循环上面的代码，也可以不使用continue</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数,如果想停⽌程序，输⼊quit:”)</p><p>​    if input_str == ‘quit’:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number &lt; 10:</p><p>​        if number % 2 == 0:</p><p>​            print(“输⼊为偶数”)</p><p>​        else:</p><p>​            print(“输⼊为奇数”)</p></blockquote><p>两段代码，实现了一样的功能，但对比一下不难发现，<strong>不使用continue，代码的嵌套层次更深</strong>，如果嵌套多了，会让代码变得难以阅读，难以管理<br>但使用continue，就可以减少代码层次，代码的理解和管理都更容易，大于10的时候continue跳过后面的代码，在逻辑思考时，这种一刀两断的方法让思路更清晰.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;③continue的好处&quot;&gt;&lt;a href=&quot;#③continue的好处&quot; class=&quot;headerlink&quot; title=&quot;③continue的好处&quot;&gt;&lt;/a&gt;③continue的好处&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;break是跳出循环体，continue是跳</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day13</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day13/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day13/</id>
    <published>2023-12-24T13:58:50.000Z</published>
    <updated>2023-12-24T14:06:42.884Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-3-while循环"><a href="#2-3-while循环" class="headerlink" title="2.3 while循环"></a>2.3 while循环</h1><h2 id="①奇偶数判断"><a href="#①奇偶数判断" class="headerlink" title="①奇偶数判断"></a>①奇偶数判断</h2><p>使用input函数接收用户输入的整数，如果是偶数，则使用print函数输出”你输入的是一个偶数”,反之输出”你输入的是一个奇数”，用户可以输入多次，直到输入quit时程序退出</p><blockquote><p>while True:</p><p>​    input_str = input(“请输⼊⼀个正整数，想退出程序请输⼊ quit:”)</p><p>​    if input_str == “quit”:</p><p>​        break</p><p>​    number = int(input_str)</p><p>​    if number % 2 == 0:</p><p>​        print(“你输⼊的是⼀个偶数”)</p><p>​    else:</p><p>​        print(“你输⼊的是⼀个奇数”)</p></blockquote><h2 id="②for循环与while循环嵌套"><a href="#②for循环与while循环嵌套" class="headerlink" title="②for循环与while循环嵌套"></a>②for循环与while循环嵌套</h2><p>已知 lst = [2, 3, 4]依次要求用户输入2，3，4 的整数倍，先让用户输入2的倍数，如果用户输入的正确，输出“输入正确”，否则输出“输入错误”，如果用户输入quit，则停止当前的输入，让用户输入3的倍数，输入3的倍数的过程中，如果用户输入quit，则让用户输入4的倍数</p><blockquote><p>lst = [2, 3, 4]</p><p>for item in lst:</p><p>​    while True:</p><p>​        input_str = input(“请输⼊{number}的倍数,想停⽌输⼊时，输⼊quit:”.format(numbe r=item))</p><p>​        if input_str == ‘quit’:</p><p>​            break</p><p>​        number = int(input_str)</p><p>​        if number % item == 0:</p><p>​            print(“输⼊正确”)</p><p>​        else:</p><p>​            print(“输⼊错误”</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-3-while循环&quot;&gt;&lt;a href=&quot;#2-3-while循环&quot; class=&quot;headerlink&quot; title=&quot;2.3 while循环&quot;&gt;&lt;/a&gt;2.3 while循环&lt;/h1&gt;&lt;h2 id=&quot;①奇偶数判断&quot;&gt;&lt;a href=&quot;#①奇偶数判断&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day12</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day12/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day12/</id>
    <published>2023-12-24T13:58:45.000Z</published>
    <updated>2023-12-24T14:06:26.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⑥寻找列表中的最大值，最小值"><a href="#⑥寻找列表中的最大值，最小值" class="headerlink" title="⑥寻找列表中的最大值，最小值"></a>⑥寻找列表中的最大值，最小值</h1><blockquote><p>lst = [3, 6, 1, 8, 1, 9 , 2]</p><p>max_value = lst[0]</p><p>​    for item in lst:</p><p>​        if item &gt; max_value:</p><p>​        max_value = item</p><p>print(max_value) </p></blockquote><p>1.参照上面的代码，写代码寻找列表的最小值</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>min_value = lst[0]</p><p>for item in lst:<br>  if item &lt; min_value:<br>    min_value = item</p><p>print(min_value)</p></blockquote><p>2.写代码寻找列表里的最小偶数</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>min_even = None</p><p>for item in lst:<br>  if item % 2 == 0:<br>    if min_even is None or item &lt; min_even:<br>      min_even = item</p><p>print(min_even)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>min_even</code> 来保存最小的偶数。初始值设置为 <code>None</code>，表示还没有找到偶数。然后，我们遍历列表中的每个元素，如果遇到偶数，则检查是否比当前的 <code>min_even</code> 更小，如果是，则更新 <code>min_even</code>。最终，输出 <code>min_even</code> 即为列表中的最小偶数。</strong></p><p>3.写代码寻找列表里的最大奇数</p><blockquote><p>lst = [3, 6, 1, 8, 1, 9, 2]</p><p>max_odd = None</p><p>for item in lst:<br>  if item % 2 != 0:<br>    if max_odd is None or item &gt; max_odd:<br>      max_odd = item</p><p>print(max_odd)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>max_odd</code> 来保存最大的奇数。初始值同样设置为 <code>None</code>，表示还没有找到奇数。然后，我们遍历列表中的每个元素，如果遇到奇数，则检查是否比当前的 <code>max_odd</code> 更大，如果是，则更新 <code>max_odd</code>。最终，输出 <code>max_odd</code> 即为列表中的最大奇数。</strong></p><p><strong>请注意，如果列表中没有奇数，那么输出结果将为 <code>None</code>，表示没有找到最大奇数。</strong></p><h1 id="⑦寻找组合"><a href="#⑦寻找组合" class="headerlink" title="⑦寻找组合"></a><strong>⑦寻找组合</strong></h1><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9 , 2]</p><p>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>for item1 in lst1:</p><p>​    for item2 in lst2:</p><p>​        if item1 + item2 == 10:</p><p>​            print((item1, item2))</p></blockquote><p><strong>上面的代码利用嵌套循环，从两个列表里各取1个数，如果这两个数的和等于10，则以元组的方式输出这两个数</strong></p><p>1.参照上面的代码，寻找两个数的差的绝对值等于2的组合</p><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9, 2]<br>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>for item1 in lst1:<br>  for item2 in lst2:<br>    if abs(item1 - item2) == 2:<br>      print((item1, item2))</p></blockquote><p>2.两个列表里各取出一个值，item1和item2， 请计算item1*item2的最大值</p><blockquote><p>lst1 = [3, 6, 1, 8, 1, 9, 2]<br>lst2 = [3, 1, 2, 6, 4, 8, 7]</p><p>max_product = float(‘-inf’)</p><p>for item1 in lst1:<br>  for item2 in lst2:<br>    product = item1 * item2<br>    if product &gt; max_product:<br>      max_product = product</p><p>print(max_product)</p></blockquote><p><strong>在上述代码中，我们引入了一个新的变量 <code>max_product</code> 来保存最大的乘积。初始值设置为负无穷 <code>-inf</code>，确保任何乘积都会比它大。然后，我们使用嵌套循环遍历 <code>lst1</code> 和 <code>lst2</code> 中的元素，计算 <code>item1 \* item2</code> 的乘积，并与当前的 <code>max_product</code> 进行比较，如果大于 <code>max_product</code>，则更新 <code>max_product</code>。最终，输出 <code>max_product</code> 即为 <code>item1 \* item2</code> 的最大值。</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⑥寻找列表中的最大值，最小值&quot;&gt;&lt;a href=&quot;#⑥寻找列表中的最大值，最小值&quot; class=&quot;headerlink&quot; title=&quot;⑥寻找列表中的最大值，最小值&quot;&gt;&lt;/a&gt;⑥寻找列表中的最大值，最小值&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;lst = [3,</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day11</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day11/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day11/</id>
    <published>2023-12-24T13:58:39.000Z</published>
    <updated>2023-12-24T14:06:11.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="④continue练习"><a href="#④continue练习" class="headerlink" title="④continue练习"></a>④continue练习</h1><p>从列表 Ist = [1,3,5,2,7,9,10] 中输出所有的奇数，代码如下</p><blockquote><p>lst = [1, 3, 5, 2, 7, 9, 10]</p><p>for item in lst:<br>  if item % 2 == 0:<br>    continue<br>  print(item)</p></blockquote><p>在上述代码中，当遇到偶数时，<code>continue</code> 语句会跳过当前迭代，直接进入下一次迭代。因此，只有奇数会被输出。</p><p>请注意，<code>continue</code> 语句后面的代码将不会被执行，而是直接进入下一次迭代。在这个例子中，当遇到偶数时，<code>print(item)</code> 这行代码将被跳过。</p><h1 id="⑤break练习"><a href="#⑤break练习" class="headerlink" title="⑤break练习"></a>⑤break练习</h1><p>从列表 Ist = [1,3,5,2,7,9,10] 中寻找1个偶数并输出，代码如下</p><blockquote><p>lst = [1, 3, 5, 2, 7, 9, 10]</p><p>for item in lst:</p><p>​    if item % 2 == 0:</p><p>​        print(item)</p><p>​        break</p></blockquote><p>题目要求寻找一个偶数，当找到这个偶数后，循环就可以终止了，使用break可以终止本次循环，你可以去掉代码中的break，再次执行代码，观察代码的执行效果</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;④continue练习&quot;&gt;&lt;a href=&quot;#④continue练习&quot; class=&quot;headerlink&quot; title=&quot;④continue练习&quot;&gt;&lt;/a&gt;④continue练习&lt;/h1&gt;&lt;p&gt;从列表 Ist = [1,3,5,2,7,9,10] 中输出所有的奇</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day10</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day10/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day10/</id>
    <published>2023-12-24T13:58:34.000Z</published>
    <updated>2023-12-24T14:05:56.449Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-2-for循环"><a href="#2-2-for循环" class="headerlink" title="2.2 for循环"></a>2.2 for循环</h1><h1 id="①range函数的基本使用"><a href="#①range函数的基本使用" class="headerlink" title="①range函数的基本使用"></a>①range函数的基本使用</h1><blockquote><p>range(3, 20, 4)</p><p>range(10, -3, -4)</p><p>range(10, 5)</p><p>range(2, 12)</p></blockquote><p>不使用代码，说出以上函数产生的整数序列</p><p><strong>解答：</strong></p><blockquote><ol><li><code>range(3, 20, 4)</code>：这个函数调用将返回一个从3开始，以4为步长递增的序列，直到小于20为止。结果为 <code>[3, 7, 11, 15, 19]</code>。</li><li><code>range(10, -3, -4)</code>：这个函数调用将返回一个从10开始，以-4为步长递减的序列，直到大于-3为止。结果为 <code>[10, 6, 2, -2]</code>。</li><li><code>range(10, 5)</code>：这个函数调用将返回一个从10开始，以1为步长递减的序列，直到大于5为止。结果为空序列，因为起始值大于结束值。</li><li><code>range(2, 12)</code>：这个函数调用将返回一个从2开始，以1为步长递增的序列，直到小于12为止。结果为 <code>[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]</code>。</li></ol></blockquote><p><strong>请注意</strong>，<code>range()</code>函数返回的是一个迭代器对象，如果需要将其转换为列表，可以使用<code>list()</code>函数进行转换。</p><h1 id="②利用range函数遍历列表"><a href="#②利用range函数遍历列表" class="headerlink" title="②利用range函数遍历列表"></a>②利用range函数遍历列表</h1><blockquote><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for index in range(len(lst)):</p><p>​    print(lst[index])</p></blockquote><p>1.参照上面的代码，从后向前遍历</p><p>2.遍历输出列表里的所有偶数</p><p>3.遍历列表，输出大于3的奇数</p><p><strong>解答：</strong></p><blockquote><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for index in range(len(lst)-1, -1, -1):<br>  print(lst[index])</p></blockquote><p>这段代码使用<code>range()</code>函数从<code>len(lst)-1</code>开始，以-1为步长递减，实现了从后向前遍历列表。</p><blockquote><p>(使用range）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for i in range(len(list)):<br>  num = list[i]<br>  if num % 2 == 0:<br>    print(“偶数:”, num)<br>  elif num % 2 == 1 and num &gt; 3:<br>    print(“大于3的奇数:”, num)</p></blockquote><blockquote><p>（未使用range 简便版）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for num in lst:<br>  if num % 2 == 0:<br>    print(num)</p></blockquote><p>这段代码遍历列表中的每个元素，通过判断元素是否为偶数，输出所有偶数。</p><blockquote><p>（使用range）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for i in range(len(lst)):<br>  num = lst[i]<br>  if num &gt; 3 and num % 2 != 0:<br>    print(num)</p></blockquote><blockquote><p>（未使用range简便版）</p><p>lst = [1, 3, 5, 2, 7, 9]</p><p>for num in lst:<br>  if num &gt; 3 and num % 2 != 0:<br>    print(num)</p></blockquote><p>这段代码遍历列表中的每个元素，通过判断元素是否大于3且为奇数，输出所有满足条件的元素。</p><h1 id="③使用for循环遍历字典"><a href="#③使用for循环遍历字典" class="headerlink" title="③使用for循环遍历字典"></a>③使用for循环遍历字典</h1><p><strong>1.仅遍历key值</strong></p><blockquote><p>dic = { ‘python’: 90, ‘java’: 95 }</p><p>for key in dic:</p><p>​    print(key, dic[key])</p></blockquote><p><strong>2.遍历key和value值</strong></p><blockquote><p>dic = { ‘python’: 90, ‘java’: 95 } for</p><p>key, value in dic.items():</p><p>​    print(key, value)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-2-for循环&quot;&gt;&lt;a href=&quot;#2-2-for循环&quot; class=&quot;headerlink&quot; title=&quot;2.2 for循环&quot;&gt;&lt;/a&gt;2.2 for循环&lt;/h1&gt;&lt;h1 id=&quot;①range函数的基本使用&quot;&gt;&lt;a href=&quot;#①range函数的基本使</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day09</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day09/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day09/</id>
    <published>2023-12-24T13:58:27.000Z</published>
    <updated>2023-12-24T14:05:38.644Z</updated>
    
    <content type="html"><![CDATA[<h1 id="③多条件分支"><a href="#③多条件分支" class="headerlink" title="③多条件分支"></a>③多条件分支</h1><p>使用input函数接收用户的输入数据，如果用户输入python，则输出90，如果用户输入java.输出95，如果用户输入php，输出85，其他输入，程序输出0</p><p><strong>解答：</strong></p><p><strong>if…elif…else</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>if value == ‘python’:</p><p>​    print(90)</p><p>elif value == ‘java’:</p><p>​    print(95)</p><p>elif value == ‘php’:</p><p>​    print(85)</p><p>else:</p><p>​    print(0)</p></blockquote><p><strong>程序流程图：</strong></p><p><img src="https://s11.ax1x.com/2023/12/24/piHKaMF.png"></p><p><strong>在Python 3.9以及之前的版本中，并没有提供真正意义上的多分支选择结构，如果确实需要可通过字典构造跳转表来实现，如下代码：</strong></p><blockquote><p>user_input = input(“请输入编程语言：”)</p><p>score_dict = {<br>  “python”: 90,<br>  “java”: 95,<br>  “php”: 85<br>}</p><p>score = score_dict.get(user_input, 0)<br>print(score)</p></blockquote><p><strong>Python 3.10新增了软关键字（只在特定场合作为关键字，普通场合也可以作为变量名）match和case，实现了真正意义上的多分支选择结构。</strong></p><p><strong>【类似c和java中的switch…case…】</strong></p><blockquote><p><strong>user_input = input(“请输入编程语言：”)</strong></p><p><strong>match user_input:<br>  case “python”:<br>    print(90)<br>  case “java”:<br>    print(95)<br>  case “php”:<br>    print(85)<br>  case _:<br>    print(0)</strong></p></blockquote><h1 id="④复杂条件判断"><a href="#④复杂条件判断" class="headerlink" title="④复杂条件判断"></a>④复杂条件判断</h1><p>使用input函数接收用户的输入，如果输入的数据不可以转换成int类型数据，则输出”无法使用<br>int函数转换”，如果可以，则将用户的输入转成int类型数据并继续判断。</p><p>如果输入数据是奇数，则将其乘以2并输出，如果是偶数，则判断是否能被4整除，如果可以则输出被4整除后的值，若不能被4整数，则判断是否大于20，如果大于20则输出与20的差值，如果小于等于20，则直接输出该值</p><p><strong>解答：</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>if not value.isdigit():</p><p>​    print(‘⽆法使⽤int函数转换’)</p><p>else:</p><p>​    i_value = int(value)</p><p>​    if i_value % 2 == 1:</p><p>​        print(i_value*2)</p><p>​    elif i_value % 4 == 0:</p><p>​        print(i_value / 4)</p><p>​    elif i_value &gt; 20:</p><p>​        print(i_value - 20)</p><p>​    else:</p><p>​        print(i_value</p></blockquote><p><strong>程序流程图：</strong></p><p><img src="https://s11.ax1x.com/2023/12/24/piHKwqJ.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;③多条件分支&quot;&gt;&lt;a href=&quot;#③多条件分支&quot; class=&quot;headerlink&quot; title=&quot;③多条件分支&quot;&gt;&lt;/a&gt;③多条件分支&lt;/h1&gt;&lt;p&gt;使用input函数接收用户的输入数据，如果用户输入python，则输出90，如果用户输入java.输出95，</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day08</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day08/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day08/</id>
    <published>2023-12-24T13:58:22.000Z</published>
    <updated>2023-12-24T14:04:00.077Z</updated>
    
    <content type="html"><![CDATA[<h1 id="2-基础语法篇"><a href="#2-基础语法篇" class="headerlink" title="2.基础语法篇"></a>2.基础语法篇</h1><h1 id="2-1-if-条件句"><a href="#2-1-if-条件句" class="headerlink" title="2.1 if 条件句"></a>2.1 if 条件句</h1><h1 id="①单个条件分支"><a href="#①单个条件分支" class="headerlink" title="①单个条件分支"></a>①单个条件分支</h1><p>使用input函数接收用户的输入，如果用户输入的整数是偶数，则使用print函数输出”你输入的整数是:{value],它是偶数”，[value]部分要替换成用户的输入。</p><p><strong>解答:</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>i_value = int(value)</p><p>if i_value % 2 == 0:</p><p>​    print(“你输⼊的整数是:{value}, 它是偶数”.format(value=value))</p></blockquote><p><strong>完成这个练习题需要掌握的4个知识点</strong><br>1.input函数的作用<br>2.字符串转int<br>3.取模运算<br>4.字符串格式化</p><h1 id="②-if…else…"><a href="#②-if…else…" class="headerlink" title="② if…else…"></a>② if…else…</h1><p>使用input函数接收用户的输入，如果用户输入的整数是偶数，则使用print函数输出”你输入的整数是:{value],它是偶数”,如果是奇数，则使用print函数输出”你输入的整数是:value],它是奇数”</p><p><strong>解答:</strong></p><blockquote><p>value = input(“请输⼊⼀个整数:”)</p><p>i_value = int(value)</p><p>if i_value % 2 == 0:</p><p>​    print(“你输⼊的整数是:{value}, 它是偶数”.format(value=value))</p><p>else:</p><p>​    print(“你输⼊的整数是:{value}, 它是奇数”.format(value=value))</p></blockquote><p><strong>程序流程图</strong></p><p><img src="/C:/Users\liuduo\Desktop\blog\source_posts\assets\piHK85q.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;2-基础语法篇&quot;&gt;&lt;a href=&quot;#2-基础语法篇&quot; class=&quot;headerlink&quot; title=&quot;2.基础语法篇&quot;&gt;&lt;/a&gt;2.基础语法篇&lt;/h1&gt;&lt;h1 id=&quot;2-1-if-条件句&quot;&gt;&lt;a href=&quot;#2-1-if-条件句&quot; class=&quot;head</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day07</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day07/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day07/</id>
    <published>2023-12-24T13:58:15.000Z</published>
    <updated>2023-12-24T14:01:29.225Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-5集合练习题"><a href="#1-5集合练习题" class="headerlink" title="1.5集合练习题"></a>1.5集合练习题</h1><p>集合间的运算</p><blockquote><p>lst1 = [1, 2, 3, 5, 6, 3, 2]</p><p>lst2 = [2, 5, 7, 9]</p></blockquote><ul><li>哪些整数既在Ist1中，也在Ist2中</li><li>哪些整数在Ist1中，不在Ist2中</li><li>两个列表一共有哪些整数</li></ul><p>虽然题目问的是两个列表之间的问题，但是用列表解答的效率很低，所以应该用集合</p><blockquote><p>lst1 = [1, 2, 3, 5, 6, 3, 2]</p><p>lst2 = [2, 5, 7, 9]</p><p>set1 = set(lst1)</p><p>set2 = set(lst2)</p><p># 哪些整数既在lst1中，也在lst2中</p><p>print(set1.intersection(set2))</p><p># 哪些整数在lst1中，不在lst2中</p><p>print(set1.difference(set2))</p><p># 两个列表⼀共有哪些整数</p><p>print(set1.union(set2)</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-5集合练习题&quot;&gt;&lt;a href=&quot;#1-5集合练习题&quot; class=&quot;headerlink&quot; title=&quot;1.5集合练习题&quot;&gt;&lt;/a&gt;1.5集合练习题&lt;/h1&gt;&lt;p&gt;集合间的运算&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;lst1 = [1, 2, 3, 5,</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day06</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day06/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day06/</id>
    <published>2023-12-12T11:05:09.000Z</published>
    <updated>2023-12-12T11:06:27.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-4字典练习题"><a href="#1-4字典练习题" class="headerlink" title="1.4字典练习题"></a>1.4字典练习题</h1><h1 id="①字典基本操作"><a href="#①字典基本操作" class="headerlink" title="①字典基本操作"></a>①字典基本操作</h1><blockquote><p>dic = { ‘python’: 95, ‘java’: 99, ‘c’: 100 }</p></blockquote><p><strong>用程序解答以下题目</strong></p><blockquote><p>1.字典的长度是多少<br>2.请修改java’这个key对应的value值为98<br>3.删除 c 这个key<br>4.增加一个key-value对，key值为 php,value是90<br>5.获取所有的key值，存储在列表里<br>6.获取所有的value值，存储在列表里</p><p>7.判断 javascript 是否在字典中<br>8.获得字典里所有value 的和<br>9.获取字典里最大的value</p><p>10.获取字典里最小的value<br>11.字典 dic1 = [php’: 97],将dic1的数据更新到dic中</p></blockquote><p><strong>解答：</strong></p><blockquote><p>第1题，len(dic),结果为3<br>第2题，dic[java] = 98,对字典里value的修改，必须通过key才可以<br>第3题，del dic[‘c]<br>第4题，dic[php] = 90<br>第5题，lst = list(dic.keys())<br>第6题，lst = list(dic.values())<br>第7题，javascript’ in dic<br>第8题，sum(dic.values()<br>第9题，max(dic.values())<br>第10题，min(dic.values())<br>第11题，dic.update(dic1)</p></blockquote><h1 id="②字典应用"><a href="#②字典应用" class="headerlink" title="②字典应用"></a><strong>②字典应用</strong></h1><p><strong>小明去超市购买水果，账单如下 ：</strong></p><blockquote><p>苹果 32.8</p><p>⾹蕉 22</p><p>葡萄 15.5</p></blockquote><p>请将上面的数据存储到字典里，可以根据水果名称查询购买这个水果的费用</p><p><strong>解答：</strong></p><blockquote><p>info = { ‘苹果’:32.8, ‘⾹蕉’: 22,’葡萄’:15.5}</p></blockquote><p>直接用水果名字做key，价格做value</p><h1 id="③字典应用（买水果2）"><a href="#③字典应用（买水果2）" class="headerlink" title="③字典应用（买水果2）"></a>③字典应用（买水果2）</h1><p>小明，小刚去超市里购买水果<br>小明购买了苹果，草莓，香蕉，一共花了89块钱，小刚购买了葡萄，橘子，樱桃，一共花了87块钱<br><strong>请从上面的描述中提取数据，存储到字典中，可以根据姓名获取这个人购买的水果种类和总费用。</strong></p><p><strong>解答：</strong></p><blockquote><p>info = {</p><p>​    ‘⼩明’: {</p><p>​        ‘fruits’: [‘苹果’, ‘草莓’, ‘⾹蕉’],</p><p>​        ‘money’: 89</p><p>​    },</p><p>​    ‘⼩刚’: {</p><p>​        ‘fruits’: [‘葡萄’, ‘橘⼦’, ‘樱桃’],</p><p>​        ‘money’: 87</p><p>​    }</p><p>}</p></blockquote><p><strong>以姓名做key，value仍然是字典</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-4字典练习题&quot;&gt;&lt;a href=&quot;#1-4字典练习题&quot; class=&quot;headerlink&quot; title=&quot;1.4字典练习题&quot;&gt;&lt;/a&gt;1.4字典练习题&lt;/h1&gt;&lt;h1 id=&quot;①字典基本操作&quot;&gt;&lt;a href=&quot;#①字典基本操作&quot; class=&quot;header</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day05</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day05/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day05/</id>
    <published>2023-09-18T12:00:09.000Z</published>
    <updated>2023-10-17T09:08:16.474Z</updated>
    
    <content type="html"><![CDATA[<h1 id="⑤合并字符串"><a href="#⑤合并字符串" class="headerlink" title="⑤合并字符串"></a>⑤合并字符串</h1><blockquote><p>str1=“1，2，3”</p><p>str2=“4，5，6”</p></blockquote><p>请将str1合并到str2的末尾，并思考这个过程中，是否产生了新的字符串</p><p><strong>解答：</strong></p><blockquote><p>str1 += str2</p></blockquote><p>这个过程中，产生的新的字符串，字符串是不可变对象，从字面意义上理解，似乎str1的内容发生变化了， 但本质上是产生了新的字符串并赋值给str1，print（str1），合并前后的内存地址是不一样的。</p><h1 id="⑥统计练习"><a href="#⑥统计练习" class="headerlink" title="⑥统计练习"></a>⑥统计练习</h1><blockquote><p>lst = [2,5,6,7,8,9,2,9,9]</p></blockquote><p><strong>请写程序完成下列题目：</strong></p><blockquote><p>1.找出列表里的最大值</p><p>2.找出列表里的最小值</p><p>3.找出列表里最大值的个数</p><p>4.计算列表里所有元素的和</p><p>5.计算列表里元素的平均值</p><p>6.计算列表的长度</p><p>7.找出元素6在列表中的索引</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. max(lst)</p><p>\2. min(lst)</p><p>\3. lst.count(max(lst))</p><p>\4. sum(lst)</p><p>\5. sum(lst)/float(len(lst))</p><p>\6. len(lst)</p><p>\7. lst.index(6)</p></blockquote><p><strong>第五题解析：</strong></p><blockquote><ul><li><code>sum(lst)</code>：这个部分是用来计算列表 <code>lst</code> 中所有元素的总和。</li><li><code>len(lst)</code>：这个部分是用来计算列表 <code>lst</code> 的长度，即列表中元素的个数。</li><li><code>float(len(lst))</code>：这个部分是将列表的长度转换为浮点数类型，以确保在进行除法运算时得到的结果是浮点数。</li><li><code>sum(lst)/float(len(lst))</code>：这个部分将列表的总和除以列表的长度，得到的结果就是列表元素的平均值。</li></ul><p><strong>这部分题考察的是对内置函数的理解和应用</strong></p></blockquote><p><strong>下面的题目不写代码，仅凭思考来回答</strong></p><blockquote><p>1.lst[2:4]的值是什么</p><p>2.lst[1: -3]的值是什么</p><p>3.lst[-5]的值是什么</p><p>4.lst[:-4] 的值是什么</p><p>5.lst[-4:] 的值是什么</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. [6, 7]</p><p>\2. [5, 6, 7, 8, 9]</p><p>\3. 8</p><p>\4. [2, 5, 6, 7, 8]</p><p>\5. [9, 2, 9, 9]</p></blockquote><p>列表的切片操作，一定要记住<strong>左闭右开</strong></p><p><strong>注意第三和第四个的区别，少一个符号的区别很大</strong></p><h1 id="⑦列表操作练习"><a href="#⑦列表操作练习" class="headerlink" title="⑦列表操作练习"></a><strong>⑦列表操作练习</strong></h1><blockquote><p>lst = [2, 5, 6, 7, 8, 9, 2, 9, 9]</p></blockquote><p><strong>请写程序完成下列题目：</strong></p><blockquote><p>请写程序完成下列操作<br>1.在列表的未尾增加元素15<br>2.在列表的中间位置插入元素20</p><p>3.将列表[2，5，6]合并到Ist中<br>4.移除列表中索引为3的元素<br>5.翻转列表里的所有元素<br>6.对列表里的元素进行排序，从小到大一次，从大到小一次</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. lst.append(15)</p><p>\2. lst.insert(len(lst)//2, 20)</p><p>\3. lst.extend([2, 5, 6])</p><p>\4. lst.remove(lst[3])</p><p>\5. lst = lst[::-1]</p><p>\6. lst.sort() lst.sort(reverse=True)</p></blockquote><p><strong>第二题解析：</strong></p><blockquote><p><code>len(lst)//2</code> 表示列表 <code>lst</code> 的长度除以2，即中间位置的索引。然后，<code>lst.insert()</code> 方法用于在指定的索引位置插入一个元素，这里的索引位置是中间位置，元素是 20。这样，执行完这段代码后，列表 <code>lst</code> 中就会在中间位置插入一个元素 20。</p></blockquote><p><strong>第五题解析：</strong></p><blockquote><p><code>lst[::-1]</code> 是 Python 中的切片操作，用于创建一个与原列表 <code>lst</code> 具有相同元素但顺序相反的新列表。具体来说：</p><ul><li><code>[::-1]</code>：这部分表示切片操作，其中的 <code>::</code> 表示从列表的起始位置到结束位置，而 <code>-1</code> 表示步长为 -1，即逆序遍历列表。</li></ul><p>通过将列表 <code>lst</code> 进行切片操作 <code>[::-1]</code>，代码将创建一个新的列表，其中的元素顺序与原列表 <code>lst</code> 相反。</p><p>例如，如果原列表 <code>lst</code> 是 <code>[1, 2, 3, 4, 5]</code>，那么 <code>lst[::-1]</code> 将返回一个新的列表 <code>[5, 4, 3, 2, 1]</code>，即原列表的逆序。</p><p>所以，<code>lst = lst[::-1]</code> 这段代码的作用是将列表 <code>lst</code> 中的元素顺序反转，并将结果保存回原列表 <code>lst</code> 中。</p></blockquote><p><strong>第六题解析：</strong></p><blockquote><p><code>lst.sort()</code> 是一个用于列表排序的方法。它会按照默认的升序方式对列表进行排序。例如，如果列表 <code>lst</code> 是 <code>[3, 1, 2]</code>，那么调用 <code>lst.sort()</code> 之后，列表 <code>lst</code> 将变为 <code>[1, 2, 3]</code>。</p><p><code>lst.sort(reverse=True)</code> 是对列表进行降序排序的方法。它会按照降序的方式对列表进行排序。例如，如果列表 <code>lst</code> 是 <code>[3, 1, 2]</code>，那么调用 <code>lst.sort(reverse=True)</code> 之后，列表 <code>lst</code> 将变为 <code>[3, 2, 1]</code>。</p><p>需要注意的是，这两个方法会直接修改原始列表，而不会返回一个新的排序后的列表。如果你想要获得一个新的排序后的列表，可以使用 <code>sorted()</code> 函数。例如，<code>sorted_lst = sorted(lst)</code> 会返回一个新的已排序列表，而不会修改原始列表 <code>lst</code>。</p></blockquote><h1 id="⑧复杂列表练习"><a href="#⑧复杂列表练习" class="headerlink" title="⑧复杂列表练习"></a><strong>⑧复杂列表练习</strong></h1><blockquote><p>lst = [1, 4, 5, [1, 3, 5, 6, [8, 9, 10, 12]]]</p></blockquote><p><strong>不写代码，仅凭思考来回答</strong></p><blockquote><p>1.列表Ist的长度是多少<br>2.列表Ist中有几个元素<br>3.lst[1] 的数据类型是什么<br>4.lst[3]的数据类型是什么<br>5.lst[3][4] 的值是什么<br>6.如果才能访问到 9 这个值<br>7.执行lst[3][4].append([5,6])后，列表lst的内容是什么，手写出来<br>8.lst[-1][-1][-2]的值是什么<br>9.lst[-2]的值是什么<br>10.len(lst[-1]) 的值是什么<br>11.len(lst[-1][-1])的值是什么<br>12.lst[-1][1:3] 的值是什么<br>13.lst[-1][-1][1:-2]的值是什么</p></blockquote><p><strong>解答：</strong></p><p>第1题和第2题其实是一个意思，原本统计列表里数据个数不是什么难事，可一旦出现了嵌套列表的情况，有人就分不清了，列表里的数据是以逗号分隔的，lst[3] 是一个列表，其余都是int类型数据，因此lst的长度是4<br>第3题，lst[1] = 4,是int类型数据<br>第4题，lst[3] 的数据类型是列表<br>第5题，lst[3]的值是[1,3,5,6,[8,9,10,12]]，仍然是一个列表，其索引为4的数据是[8,9,10,12]，是列表<br>第6题，lst[3][4][1]第7题，[1,4,5,[1,3,5,6,[8,9,10,12,[5,6]]]],参考5，6两个题目的解答第8题，Ist[-1]的值是[1,3,5,6,[8,9,10,12]]， 再次取索引为-1的数据为[8,9,10,12]，取索引为-2的数据为10<br>第9题，5<br>第10题，5<br>第11题，4<br>第12题，[3,5]， lst[-1]的值是[1,3,5,6,[8,9,10,12]]第13题，[9]， lst[-1][-1]的值是[8,9,10,12]，切片起始位置索引是1，值为9，结束位置是-2，值为10，由于左闭右开，最终结果是[9]</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;⑤合并字符串&quot;&gt;&lt;a href=&quot;#⑤合并字符串&quot; class=&quot;headerlink&quot; title=&quot;⑤合并字符串&quot;&gt;&lt;/a&gt;⑤合并字符串&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;str1=“1，2，3”&lt;/p&gt;
&lt;p&gt;str2=“4，5，6”&lt;/p&gt;
&lt;/bl</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day04</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day04/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day04/</id>
    <published>2023-09-17T12:00:02.000Z</published>
    <updated>2023-10-17T09:08:16.472Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-3列表与元组练习题"><a href="#1-3列表与元组练习题" class="headerlink" title="1.3列表与元组练习题"></a>1.3列表与元组练习题</h1><h1 id="①列表基础考察"><a href="#①列表基础考察" class="headerlink" title="①列表基础考察"></a>①列表基础考察</h1><p>已知一个列表<strong>lst = [1,2,3,4,5]</strong><br>1.求列表的长度<br>2.判断6 是否在列表中<br>3.lst + [6,7,8] 的结果是什么?<br>4.lst*2 的结果是什么<br>5.列表里元素的最大值是多少<br>6.列表里元素的最小值是多少<br>7.列表里所有元素的和是多少<br>8.在索引1的后面新增一个的元素109.在列表的未尾新增一个元素20</p><p><strong>解答：</strong></p><blockquote><p>\1. len(lst)</p><p>\2. 6 in lst</p><p>\3. [1,2,3,4,5,6,7,8]</p><p>\4. [1, 2, 3, 4, 5, 1, 2, 3, 4, 5]</p><p>\5. max(lst)</p><p>\6. min(lst)</p><p>\7. sum(lst)</p><p>\8. lst.insert(1, 10)</p><p>\9. lst.append(20)</p></blockquote><h1 id="②修改列表"><a href="#②修改列表" class="headerlink" title="②修改列表"></a>②修改列表</h1><p><strong>lst = [1, [4, 6],True]</strong></p><p><strong>请将列表里所有数字修改成原来的两倍</strong></p><p>答案：</p><blockquote><p>lst[0] = 2</p><p>lst[1][0] = 4</p><p>lst[1][1] = 12</p></blockquote><p><strong>你以为存在一个函数，其功能便是将列表里所有的数据都变成原来的两倍，这样才显得变成语言是一个非常神奇的东西，但是很遗憾的告诉你，那些神奇的东西都是程序员自己实现的。</strong></p><p><strong>想要修改列表里的数据，必须通过索引对其重新赋值，上面的方法很low，你也可以写一个区数来实现这个功能，我们假设要处理的列表里只int,float,bool,和list数据，不管嵌套基层list.这个函数都应该能正确处理，下面是一段示例代码</strong></p><blockquote><p>def double_list(lst):</p><p>​    for index,item in enumerate(lst):<br>​        if isinstance(item,bool):</p><p>​            continue</p><p>​        if isinstance(item,(int,float)):</p><p>​            lst[index]*=2</p><p>​        if isinstance(item,list):</p><p>​            double_list(item)</p><p>if <em>name</em> == ‘<em>main</em>‘:</p><p>​    lst = [1,[4,6],True]</p><p>​    double_list(lst)</p><p>​    print(lst)</p></blockquote><h1 id="③元组概念考察"><a href="#③元组概念考察" class="headerlink" title="③元组概念考察"></a>③元组概念考察</h1><p><strong>写出下面代码的执行结果和最终结果的类型</strong></p><p>\1. (1,2)*2</p><p>\2. (1,)*2</p><p>\3. (1)*2</p><p><strong>解答：</strong></p><blockquote><p>\1. (1, 2, 1, 2)</p><p>\2. (1, 1)</p><p>\3. 2</p></blockquote><p>注意第2和第3个，当元组里只有一个数据时，必须有逗号，否则就变成了第三题的形式：<strong>1*2</strong></p><p><strong>当元组中只有一个数据时，如果不省略了逗号，那么小括号的作用就不再是表示元组，而是表示运算优先级</strong></p><h1 id="④合并列表"><a href="#④合并列表" class="headerlink" title="④合并列表"></a><strong>④合并列表</strong></h1><p>lst = [1,2,3]</p><p>lst2 = [4,5,6]</p><p><strong>不使用＋号运算符，将lst2合并到lst的末尾，并思考，这个过程中，是否产生了新的列表</strong></p><p><strong>解答：</strong></p><blockquote><p>lst.extend(lst2)</p></blockquote><p><strong>这个过程中不会产生新的列表，最直观的检验方式就是print(id(lst)),合并前后，lst的内存地址都没有发生变化，只是列表里的内容发生了变化</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-3列表与元组练习题&quot;&gt;&lt;a href=&quot;#1-3列表与元组练习题&quot; class=&quot;headerlink&quot; title=&quot;1.3列表与元组练习题&quot;&gt;&lt;/a&gt;1.3列表与元组练习题&lt;/h1&gt;&lt;h1 id=&quot;①列表基础考察&quot;&gt;&lt;a href=&quot;#①列表基础考察&quot; c</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day03</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day03/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day03/</id>
    <published>2023-09-16T11:59:35.000Z</published>
    <updated>2023-10-17T09:08:16.471Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-2字符串练习题"><a href="#1-2字符串练习题" class="headerlink" title="1.2字符串练习题"></a>1.2字符串练习题</h1><h1 id="①字符串内置方法练习"><a href="#①字符串内置方法练习" class="headerlink" title="①字符串内置方法练习"></a>①字符串内置方法练习</h1><blockquote><p><strong>在交互式解释器中完成下列题目</strong><br>1.将字符串“abcd”转成大写<br>2.计算字符串“cd”在 字符串“abcd”中出现的位置<br>3.字符串“a,b,c,d”，请用逗号分割字符串，分割后的结果是什么类型的？</p><p>4.”[name]喜欢{fruit}”.format(name=”李雷”)执行会出错，请修改代码让其正确执行</p><p>\5. string =”Python is good”, 请将字符串里的Python替换成 python,并输出替换后的结果<br>6.有一个字符串 string =“python修炼第一期.html”，请写程序从这个字符串里获得.htm前面的部分，要用尽可能多的方式来做这个事情<br>7.如何获取字符串的长度?<br>8.”this is a book”,请将字符串里的book替换成apple<br>9.”this is a book”,请用程序判断该字符串是否以this开头</p><p>10.”this is a book”，请用程序判断该字符串是否以apple结尾</p><p>11.”This IS a book”请将字符串里的大写字符转成小写字符<br>12.”This IS a book”,请将字符串里的小写字符转成大写字符<br>13.”this is a book\n”,字符串的末尾有一个回车符，请将其删除</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. “abcd”.upper()<br>\2. “abcd”.find(‘cd’)<br>\3. “a,b,c,d”.split(‘,’)<br>\4. “{name}喜欢{fruit}”.format(name=”李雷”, fruit=’苹果’)<br>\5. string.replace(‘Python’, ‘python’)<br>\6. string[0:string.find(‘.html’)] 或者string[0:-5]<br>\7. 使⽤用len函数<br>\8. “this is a book”.replace(‘book’, ‘apple’)<br>\9. “this is a book”.startswith(‘this’)<br>\10. “this is a book”.endswith(‘apple’)<br>\11. “This IS a book”.lower()<br>\12. “This IS a book”.upper()<br>\13. “this is a book\n”.strip()</p></blockquote><p><strong>这里只对其中2个题目讲解</strong></p><p>第4小题的程序直接运行会报错，因为字符串里面有两个需要替换的位置，而format方法里只传入了一个参数，显然是不够</p><p>第13小题，strip()方法用于移除字符串头尾指定的字符(默认为空格或换行符)或字符序列，n 就是换行符，这里又涉及到转义字符这个概念，本篇不做详细讲解，求知欲强的同学可以自己百度一下</p><h1 id="②逻辑推理练习（字符串）"><a href="#②逻辑推理练习（字符串）" class="headerlink" title="②逻辑推理练习（字符串）"></a>②逻辑推理练习（字符串）</h1><blockquote><p><strong>不用代码，口述回答下面代码的执行结果</strong></p><p>string = “Python is good”<br>\1. string[1:20]</p><p>\2. string[20]</p><p>3.string[3:-4]<br>4.string[-10:-3]<br>5.string.lower()<br>6.string.replace(“o”，”0”)</p><p>\7. string.startswith(python’)<br>\8. string.split()<br>\9. len(string)<br>\10. string[30]<br>11.string.replace(“”,”)</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. ‘ython is good’<br>\2. 报错<br>\3. ‘hon is ‘<br>\4. ‘on is g’<br>\5. ‘python is good’<br>\6. ‘Pyth0n is g00d’<br>\7. False<br>\8. [‘Python’, ‘is’, ‘good’]<br>\9. 14<br>\10. 报错<br>\11. ‘Pythonisgood’</p></blockquote><p><strong>第2题和第10题</strong>都报错，是因为超出了索引范围，字符串长度为14，你去20和30的位置取值，当然会报错<br>关于<strong>切片操作</strong>，只需要知道从哪里开始到哪里结束就一定能推导出答案，以string[3:-4]为例，3是开始的位置，-4是结束的位置，但这个范围是左闭右开的，从3开始没错，但不会到-4，而是到-5，更前面的一个位置，python支持负数索引，或者说是反向索引，从右向左从-1开始逐渐减小。<br>第一题中，做切片的时候是从1开始，到20结束，即便是右开，直到19，也仍然超出了索引范围，为什么不报错呢，这就是语言设计者自己的想法了，切片时，不论是开始位置还是结束位置，超出索引范围都不会报错，我猜，大概是由于切片是一个范围操作，这个范围内有值就切出来，没值返回空字符串就好了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-2字符串练习题&quot;&gt;&lt;a href=&quot;#1-2字符串练习题&quot; class=&quot;headerlink&quot; title=&quot;1.2字符串练习题&quot;&gt;&lt;/a&gt;1.2字符串练习题&lt;/h1&gt;&lt;h1 id=&quot;①字符串内置方法练习&quot;&gt;&lt;a href=&quot;#①字符串内置方法练习&quot; cla</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day02</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day02/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day02/</id>
    <published>2023-09-15T07:59:10.000Z</published>
    <updated>2023-10-17T09:08:16.470Z</updated>
    
    <content type="html"><![CDATA[<h1 id="②数据类型考察"><a href="#②数据类型考察" class="headerlink" title="②数据类型考察"></a>②数据类型考察</h1><p><strong>请说出下面表达式结果的类型</strong></p><blockquote><p>\1. “True”<br>\2. “Flase”<br>\3. 4 &gt;= 5<br>\4. 5<br>\5. 5.0<br>\6. True</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. str<br>\2. str<br>\3. bool<br>\4. int<br>\5. float<br>\6. bool</p></blockquote><p>唯一需要解释的就是4&gt;=5，这是错误的，所以等于false，false的类型是bool</p><h1 id="③交互式解释器练习"><a href="#③交互式解释器练习" class="headerlink" title="③交互式解释器练习"></a>③交互式解释器练习</h1><p><strong>请在交互式解释器里回答下面的题目</strong></p><blockquote><p>\1. 3的5次⽅方<br>\2. 7对2求模<br>\3. 9除5，要求有⼩小数部分<br>\4. 9除5，要求没有⼩小数部分<br>\5. ⽤用程序计算根号16，也就是16的2分之⼀一次⽅方</p></blockquote><p><strong>解答：</strong></p><blockquote><p>\1. 3**5<br>\2. 7%2<br>\3. 9/5<br>\4. 9//5<br>\5. import math<br>math.sqrt(16)</p></blockquote><p><strong>知识点：</strong></p><ol><li>幂运算用两个*</li><li>求模运算用%，其实就是求余数</li><li>除法中，结果保留小数部分用/，结果取整数用//</li><li>开根号，需要用到math模块的sqrt方法，和c还有java都大差不差</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;②数据类型考察&quot;&gt;&lt;a href=&quot;#②数据类型考察&quot; class=&quot;headerlink&quot; title=&quot;②数据类型考察&quot;&gt;&lt;/a&gt;②数据类型考察&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;请说出下面表达式结果的类型&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
  <entry>
    <title>Python150题day01</title>
    <link href="https://bdta-zky.github.io/Python150%E9%A2%98day01/"/>
    <id>https://bdta-zky.github.io/Python150%E9%A2%98day01/</id>
    <published>2023-09-14T10:42:50.000Z</published>
    <updated>2023-10-17T09:08:16.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-1基本数据类型"><a href="#1-1基本数据类型" class="headerlink" title="1.1基本数据类型"></a>1.1基本数据类型</h1><p><strong>①逻辑推理联系（类型转换）</strong></p><blockquote><p>\1. 4.0 == 4</p><p>\2. “4.0” == 4</p><p>\3. bool(“1”)</p><p>\4. bool(“0”)</p><p>\5. str(32)</p><p>\6. int(6.26)</p><p>\7. float(32)</p><p>\8. float(“3.21”)</p><p>\9. int(“434”)</p><p>\10. int(“3.42”)</p><p>\11. bool(-1)</p><p>\12. bool(“”)</p><p>\13. bool(0)</p><p>\14. “wrqq” &gt; “acd”</p><p>\15. “ttt” == “ttt “</p><p>\16. “sd”*3</p><p>\17. “wer” + “2322”</p></blockquote><p><strong>答案：</strong></p><blockquote><p>\1. True </p><p>\2. False</p><p>\3. True</p><p>\4. True</p><p>\5. ‘32’</p><p>\6. 6</p><p>\7. 32.0</p><p>\8. 3.21</p><p>\9. 434</p><p>\10. 会报错</p><p>\11. True</p><p>\12. False</p><p>\13. False </p><p>\14. True</p><p>\15. False</p><p>\16. “sdsdsd”</p><p>\17. ‘wer2322</p></blockquote><p><strong>解析：</strong></p><blockquote><ol><li>4.0 == 4 ：在Python中，双等号（==）用于比较两个值是否相等。在这种情况下，4.0和4都表示相同的数值，因此它们是相等的，结果为True。</li><li>“4.0” == 4：这个表达式也是一个比较运算符，检查字符串”4.0”是否等于整数4。这是一个错误的比较，因为字符串和整数是不同的类型。表达式的结果为False。</li><li>bool(“1”)：这个表达式使用bool()函数将字符串”1”转换为布尔值。在Python中，非空字符串被视为True，因此表达式的结果为True。</li><li>bool(“0”)：这个表达式使用bool()函数将字符串”0”转换为布尔值。在Python中，非空字符串被视为True，因此表达式的结果为True。</li><li>str(32)：这个表达式使用str()函数将整数32转换为字符串。结果是字符串”32”。</li><li>int(6.26)：这个表达式使用int()函数将浮点数6.26转换为整数。结果是整数6，小数部分被截断。</li><li>float(32)：这个表达式使用float()函数将整数32转换为浮点数。结果是浮点数32.0。</li><li>float(“3.21”)：这个表达式使用float()函数将字符串”3.21”转换为浮点数。结果是浮点数3.21。</li><li>int(“434”)：这个表达式使用int()函数将字符串”434”转换为整数。结果是整数434。</li><li>int(“3.42”)：这个表达式使用int()函数将字符串”3.42”转换为整数。由于字符串表示的是浮点数，而int()函数只能将字符串转换为整数，因此会引发ValueError异常。</li><li>bool(-1)：这个表达式将整数-1转换为布尔值。在Python中，非零整数被视为True，因此表达式的结果为True。</li><li>bool(“”)：这个表达式将空字符串转换为布尔值。在Python中，空字符串被视为False，因此表达式的结果为False。</li><li>bool(0)：这个表达式将整数0转换为布尔值。在Python中，0被视为False，因此表达式的结果为False。</li><li>“wrqq” &gt; “acd”：这个表达式是一个字符串的比较运算符，检查字符串”wrqq”是否大于字符串”acd”。在字符串比较中，根据字母的字典顺序进行比较。根据字母顺序，”w”大于”a”，因此表达式的结果为True。</li><li>“ttt” == “ttt “：这个表达式是一个字符串的比较运算符，检查字符串”ttt”是否等于字符串”ttt “。这两个字符串是不相等的，因为它们的长度不同。表达式的结果为False。</li><li>“sd” * 3：这个表达式使用乘法运算符将字符串”sd”重复3次。结果是字符串”sdsdsd”。</li><li>“wer” + “2322”：这个表达式使用加法运算符将字符串”wer”和字符串”2322”连接起来。结果是字符串”wer2322”。</li></ol></blockquote><p><strong>注意点：</strong></p><blockquote><h2 id="bool函数转换规则"><a href="#bool函数转换规则" class="headerlink" title="bool函数转换规则"></a><strong>bool函数转换规则</strong></h2><p>bool函数进行转换时，其结果取决于传入参数与True和False的等价关系，只需记住一点即0，空字符串，None在条件判断语句中等价于False，其他数值都等价于True</p></blockquote><blockquote><h2 id="int-“3-42”-为什么会报错"><a href="#int-“3-42”-为什么会报错" class="headerlink" title="int(“3.42”) 为什么会报错"></a><strong>int(“3.42”) 为什么会报错</strong></h2><p>字符串”3.42”可以转成foat类型数据3.42,3.42可以转成int类型数据3，但是字符串”3.42”不可以直接使用int函数转成3，讲实话，我也觉得这个函数有些不灵活，或许是语言的发昨有自己的考虑吧，咱们对这种问题，不必深究，先做到知道它是什么，将来再去研究为什么</p></blockquote><blockquote><h2 id="字符串大小比较规则"><a href="#字符串大小比较规则" class="headerlink" title="字符串大小比较规则"></a>字符串大小比较规则</h2><p>两个字符串在比较大小时，比的不是长度，而是内容字符串左对齐后，逐个字符依次比较，直到可以分出胜负</p></blockquote><blockquote><h2 id="“sd”-3"><a href="#“sd”-3" class="headerlink" title="“sd”*3"></a>“sd”*3</h2><p>“sd”*3 的意思是sd重复3次，生成一个新的字符串</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;1-1基本数据类型&quot;&gt;&lt;a href=&quot;#1-1基本数据类型&quot; class=&quot;headerlink&quot; title=&quot;1.1基本数据类型&quot;&gt;&lt;/a&gt;1.1基本数据类型&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;①逻辑推理联系（类型转换）&lt;/strong&gt;&lt;/p&gt;
&lt;blockq</summary>
      
    
    
    
    <category term="python" scheme="https://bdta-zky.github.io/categories/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/categories/python/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
    
    <category term="python" scheme="https://bdta-zky.github.io/tags/python/"/>
    
    <category term="入门150题专栏" scheme="https://bdta-zky.github.io/tags/%E5%85%A5%E9%97%A8150%E9%A2%98%E4%B8%93%E6%A0%8F/"/>
    
  </entry>
  
</feed>
